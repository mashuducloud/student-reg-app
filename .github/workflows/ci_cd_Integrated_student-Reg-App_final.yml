---
name: "CI/CD (Definitive)"

on:
  workflow_dispatch:
    inputs:
      ECR_PURGE:
        description: >
          Delete & recreate target ECR repos before publish (DANGEROUS)
        required: false
        default: "true"
  push:
    branches: [dev, main, master]
  pull_request:
    branches: ["main", "master"]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write
  packages: write

env:
  PYTHON_VERSION: "3.11"
  AWS_REGION: us-east-1
  ECR_REGISTRY: 724772092393.dkr.ecr.us-east-1.amazonaws.com
  ECR_PUBLIC_ALIAS: mashkenneth
  BACKEND_DOCKERFILE: infra/Dockerfile.backend
  FRONTEND_DOCKERFILE: infra/Dockerfile.frontend
  IMAGE_BACKEND_LOCAL: student-backend:ci
  IMAGE_FRONTEND_LOCAL: student-frontend:ci
  ECR_PURGE: ${{ inputs.ECR_PURGE || secrets.ECR_PURGE || 'true' }}
  PROMETHEUS_VERSION: "v2.54.1"
  GRAFANA_VERSION: "11.2.0"
  OTELCOL_VERSION: "0.108.0"
  TEMPO_VERSION: "2.5.0"

jobs:
  # ----------------------------------------------------------------------------
  # STAGE 1: Continuous Integration (CI)
  # ----------------------------------------------------------------------------
  quality-checks:
    name: "CI: Quality Checks"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: "Set up Python"
        uses: actions/setup-python@v5
        with:
          python-version: "${{ env.PYTHON_VERSION }}"
          cache: pip
          cache-dependency-path: backend/requirements-ci.txt

      - name: "Install tools"
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements-ci.txt

      - name: "Python Lint & Format (ruff)"
        run: |
          ruff check backend/
          ruff format --check backend/

      - name: "Security Lint (bandit)"
        run: bandit -r backend/ || true

      - name: "Dependency Security Scan (pip-audit)"
        run: |
          pip install -r backend/requirements.txt
          pip-audit -r backend/requirements.txt

      - name: "Comprehensive YAML Lint"
        run: yamllint -c .yamllint.yml .

  build-and-scan:
    name: "CI: Build, Scan & Artifacts"
    runs-on: ubuntu-latest
    needs: [quality-checks]
    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-buildx-action@v3

      - name: "Build backend image"
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ env.BACKEND_DOCKERFILE }}
          tags: ${{ env.IMAGE_BACKEND_LOCAL }}
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: "Build frontend image"
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ env.FRONTEND_DOCKERFILE }}
          tags: ${{ env.IMAGE_FRONTEND_LOCAL }}
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: "Trivy Scan — BACKEND"
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_BACKEND_LOCAL }}
          severity: "HIGH,CRITICAL"
          ignore-unfixed: true
          exit-code: 1

      - name: "Trivy Scan — FRONTEND"
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_FRONTEND_LOCAL }}
          severity: "HIGH,CRITICAL"
          ignore-unfixed: true
          exit-code: 1

      - name: "Save Docker images for subsequent jobs"
        run: |
          docker save ${{ env.IMAGE_BACKEND_LOCAL }} | gzip > backend-image.tar.gz
          docker save ${{ env.IMAGE_FRONTEND_LOCAL }} | gzip > frontend-image.tar.gz

      - name: "Upload image artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: image-artifacts
          path: |
            backend-image.tar.gz
            frontend-image.tar.gz
          retention-days: 7

  infra-smoke-and-tests:
    name: "CI: Integration Tests & Reports"
    runs-on: ubuntu-latest
    needs: [build-and-scan]
    steps:
      - uses: actions/checkout@v4

      - name: "Download image artifacts"
        uses: actions/download-artifact@v4
        with:
          name: image-artifacts

      - name: "Load Docker images"
        run: gzip -dc backend-image.tar.gz | docker load && gzip -dc frontend-image.tar.gz | docker load

      - name: "Prepare .env for docker-compose"
        env:
          DB_SECRET: ${{ secrets.DB_SECRET }}
        run: |
          set -e
          mkdir -p infra
          if [ -n "${DB_SECRET:-}" ]; then
            printf "%s\n" "${DB_SECRET}" > infra/.env
          else
            echo "::error::DB_SECRET is not set."
            exit 1
          fi

      - name: "Start services using Docker Compose"
        run: docker compose --env-file infra/.env -f infra/docker-compose.yml up -d

      - name: "Prepare helper scripts"
        run: |
          set -e
          shopt -s nullglob
          for f in .github/scripts/*.sh; do
            sed -i 's/\r$//' "$f"
            chmod +x "$f"
          done

      - name: "Wait for services and run health checks"
        run: |
          if [ -f ./.github/scripts/health-check.sh ]; then
            bash ./.github/scripts/health-check.sh
          else
            echo "health-check.sh not found, sleeping for 30s as a fallback..."
            sleep 30
          fi

      - name: "Run backend tests + coverage"
        run: |
          mkdir -p coverage
          docker compose -f infra/docker-compose.yml run --rm \
            -v "$PWD/coverage:/app/coverage" \
            tests \
            pytest --cov=. \
              --cov-report=xml:coverage/coverage.xml \
              --cov-report=html:coverage/htmlcov \
              -v

      - name: "Upload Test & Coverage Artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: test-reports
          path: coverage/
          if-no-files-found: ignore
          retention-days: 7

      - name: "Tear down services"
        if: always()
        run: docker compose -f infra/docker-compose.yml down -v

  open-pr-when-ahead:
    name: "CI: Auto PR dev → default"
    runs-on: ubuntu-latest
    needs: [infra-smoke-and-tests]
    if: success() && github.ref == 'refs/heads/dev' && github.event_name == 'push'
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_TOKEN || github.token }}
          script: |
            const { owner, repo } = context.repo;
            const { data: repoData } = await github.request(
              'GET /repos/{owner}/{repo}',
              { owner, repo }
            );
            const base = repoData.default_branch;
            const head = 'dev';
            if (base === head) return;

            try {
              const cmp = await github.request(
                'GET /repos/{owner}/{repo}/compare/{base}...{head}',
                { owner, repo, base, head }
              );
              const ahead_by = cmp.data.ahead_by || 0;
              if (ahead_by === 0) {
                core.info('dev is not ahead; skipping PR creation.');
                return;
              }
            } catch (e) {
              core.warning(`Compare failed (possibly unrelated histories): ${e.message}`);
              return;
            }

            const { data: prs } = await github.rest.pulls.list({
              owner, repo, state: 'open', base,
              head: `${owner}:${head}`
            });
            if (prs.length > 0) {
              core.info('PR already exists.');
              return;
            }

            try {
              await github.rest.pulls.create({
                owner, repo, head, base,
                title: `Auto PR: ${head} → ${base}`,
                body: 'Opened by CI.'
              });
            } catch (e) {
              core.warning(`Could not create PR (likely permissions): ${e.message}`);
            }

  # ----------------------------------------------------------------------------
  # STAGE 2: Continuous Deployment (CD)
  # ----------------------------------------------------------------------------
  publish-preprod:
    name: "CD: Deploy to Pre-Prod"
    runs-on: ubuntu-latest
    needs: [infra-smoke-and-tests]
    if: >-
      success() && github.event_name == 'push' && (
        github.ref == 'refs/heads/main' ||
        github.ref == 'refs/heads/master'
      )
    environment: pre-production
    env:
      APP_REPO: mashkenneth/public-student-reg-app/pre-prod
      SIG_REPO: mashkenneth/public-student-reg-app/pre-prod-sig
      OBS_REPO: public-student-reg-app-pre-prod-observability
    steps:
      - name: "Gate: ensure merged PR was from dev"
        id: gate
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const { owner, repo } = context.repo;
            const sha = context.sha;
            const { data: prs } = await github.request(
              'GET /repos/{owner}/{repo}/commits/{ref}/pulls',
              { owner, repo, ref: sha, mediaType: { previews: ['groot'] } }
            );
            const ok = prs.some(pr =>
              pr.merged_at &&
              pr.state === 'closed' &&
              pr.base &&
              (pr.base.ref === 'main' || pr.base.ref === 'master') &&
              pr.head &&
              pr.head.ref === 'dev'
            );
            core.setOutput('ok', ok ? 'true' : 'false');
            if (!ok) {
              core.info('No merged PR from dev → main/master for this commit; skip pre-prod deploy.');
            }

      - name: "Configure AWS Credentials"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "Sanity check caller identity"
        if: ${{steps.gate.outputs.ok == 'true'}}
        run: aws sts get-caller-identity

      - name: "(Dangerous) Delete & recreate ECR Private repos"
        if: ${{steps.gate.outputs.ok == 'true' && env.ECR_PURGE == 'true'}}
        run: |
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            if aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1; then
              aws ecr delete-repository --repository-name "${repo}" --force
            fi
            aws ecr create-repository --repository-name "${repo}"
          done

      - name: "(Dangerous) Delete & recreate ECR Public repo"
        if: ${{steps.gate.outputs.ok == 'true' && env.ECR_PURGE == 'true'}}
        run: |
          if aws ecr-public describe-repositories \
            --repository-names "${{ env.OBS_REPO }}" >/dev/null 2>&1; then
            aws ecr-public delete-repository \
              --repository-name "${{ env.OBS_REPO }}" --force
          fi
          aws ecr-public create-repository --repository-name "${{ env.OBS_REPO }}"

      - name: "Download image artifacts"
        if: ${{steps.gate.outputs.ok == 'true'}}
        uses: actions/download-artifact@v4
        with:
          name: image-artifacts

      - name: "Load Docker images"
        if: ${{steps.gate.outputs.ok == 'true'}}
        run: gzip -dc backend-image.tar.gz | docker load && gzip -dc frontend-image.tar.gz | docker load

      - name: "Login to Amazon ECR (Private and Public)"
        if: ${{steps.gate.outputs.ok == 'true'}}
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
          | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
          aws ecr-public get-login-password --region us-east-1 \
          | docker login --username AWS --password-stdin public.ecr.aws

      - name: "Ensure Private ECR repos exist (preprod)"
        if: ${{steps.gate.outputs.ok == 'true'}}
        run: |
          set -e
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            aws ecr describe-repositories --repository-names "$repo" >/dev/null 2>&1 \
            || aws ecr create-repository --repository-name "$repo"
          done

      - name: "Detect ECR Public alias + ensure repo (preprod)"
        if: ${{steps.gate.outputs.ok == 'true'}}
        id: ecrpub_pre
        env:
          AWS_REGION: us-east-1
        run: |
          set -e
          ALIAS="$(aws ecr-public describe-registries \
            --region "$AWS_REGION" \
            --query "registries[].aliases[].name | [0]" \
            --output text)"
          if [ -z "$ALIAS" ] || [ "$ALIAS" = "None" ]; then
            echo "::error::No ECR Public alias on this account. Create one in AWS console."
            exit 1
          fi
          echo "alias=$ALIAS" >> "$GITHUB_OUTPUT"

          aws ecr-public get-login-password --region "$AWS_REGION" \
          | docker login --username AWS --password-stdin public.ecr.aws

          aws ecr-public describe-repositories \
            --region "$AWS_REGION" \
            --repository-names "${{ env.OBS_REPO }}" >/dev/null 2>&1 \
          || aws ecr-public create-repository \
               --region "$AWS_REGION" \
               --repository-name "${{ env.OBS_REPO }}"

      - name: "Show detected ECR Public alias (preprod)"
        if: ${{ steps.gate.outputs.ok == 'true' }}"

        run: |
          echo "Detected alias (output): ${{ steps.ecrpub_pre.outputs.alias }}"
          aws ecr-public describe-registries --region us-east-1 \
            --query "registries[].aliases[].name | [0]" --output text

      - name: "Push App Images to Private ECR (preprod)"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        env:
          SHA: ${{ github.sha }}
        run: |
          set -ex
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"

          echo "== Show local images (before tagging) =="
          docker images --format '{{.Repository}}:{{.Tag}}' | sort | uniq | sed -n '1,200p'

          docker tag "${IMAGE_BACKEND_LOCAL}"  "${IMAGE_DEST}:backend-${SHA::12}"
          docker tag "${IMAGE_FRONTEND_LOCAL}" "${IMAGE_DEST}:frontend-${SHA::12}"

          echo "== Show the ECR-tagged images we will push =="
          docker images "${IMAGE_DEST}" --format '{{.Repository}}:{{.Tag}}'

          echo "== Push each tag explicitly =="
          docker push "${IMAGE_DEST}:backend-${SHA::12}"
          docker push "${IMAGE_DEST}:frontend-${SHA::12}"

          echo "== Verify images now exist in ECR (preprod) =="
          aws ecr list-images --repository-name "${APP_REPO}" \
            --query 'imageIds[].imageTag' --output text

      - name: "Install cosign"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        uses: sigstore/cosign-installer@v3.6.0

      - name: "Sign Private images"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        env:
          SHA: ${{ github.sha }}
        run: |
          export COSIGN_REPOSITORY="${ECR_REGISTRY}/${SIG_REPO}"
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"
          cosign sign --yes "${IMAGE_DEST}:backend-${SHA::12}"
          cosign sign --yes "${IMAGE_DEST}:frontend-${SHA::12}"

      - name: "Push Observability Stack to Public ECR"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        env:
          AWS_REGION: us-east-1
        run: |
          set -ex
          REG="public.ecr.aws/${{ steps.ecrpub_pre.outputs.alias }}"

          UPSTREAM_PROM="prom/prometheus:${{ env.PROMETHEUS_VERSION }}"
          TARGET_PROM="${REG}/${{ env.OBS_REPO }}:prometheus-${{ env.PROMETHEUS_VERSION }}"
          docker pull "$UPSTREAM_PROM"
          docker tag "$UPSTREAM_PROM" "$TARGET_PROM"
          docker push "$TARGET_PROM"

          UPSTREAM_GRAF="grafana/grafana:${{ env.GRAFANA_VERSION }}"
          TARGET_GRAF="${REG}/${{ env.OBS_REPO }}:grafana-${{ env.GRAFANA_VERSION }}"
          docker pull "$UPSTREAM_GRAF"
          docker tag "$UPSTREAM_GRAF" "$TARGET_GRAF"
          docker push "$TARGET_GRAF"

          UPSTREAM_OTEL="otel/opentelemetry-collector:${{ env.OTELCOL_VERSION }}"
          TARGET_OTEL="${REG}/${{ env.OBS_REPO }}:otelcol-${{ env.OTELCOL_VERSION }}"
          docker pull "$UPSTREAM_OTEL"
          docker tag "$UPSTREAM_OTEL" "$TARGET_OTEL"
          docker push "$TARGET_OTEL"

          UPSTREAM_TEMPO="grafana/tempo:${{ env.TEMPO_VERSION }}"
          TARGET_TEMPO="${REG}/${{ env.OBS_REPO }}:tempo-${{ env.TEMPO_VERSION }}"
          docker pull "$UPSTREAM_TEMPO"
          docker tag "$UPSTREAM_TEMPO" "$TARGET_TEMPO"
          docker push "$TARGET_TEMPO"

  publish-prod:
    name: "CD: Deploy to Production"
    runs-on: ubuntu-latest
    needs: [infra-smoke-and-tests]
    if: >-
      success() && (
        github.ref == 'refs/heads/main' ||
        github.ref == 'refs/heads/master'
      ) && github.event_name == 'push'
    environment: production
    env:
      APP_REPO: mashkenneth/public-student-reg-app/prod
      SIG_REPO: mashkenneth/public-student-reg-app/prod-sig
      OBS_REPO: public-student-reg-app-prod-observability
    steps:
      - name: "Configure AWS Credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "Sanity check caller identity"
        run: aws sts get-caller-identity

      - name: "(Dangerous) Delete & recreate ECR Private repos"
        if: env.ECR_PURGE == 'true'
        run: |
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            aws ecr delete-repository --repository-name "${repo}" --force || true
            aws ecr create-repository --repository-name "${repo}"
          done

      - name: "(Dangerous) Delete & recreate ECR Public repo"
        if: env.ECR_PURGE == 'true'
        run: |
          aws ecr-public delete-repository \
            --repository-name "${{ env.OBS_REPO }}" --force || true
          aws ecr-public create-repository \
            --repository-name "${{ env.OBS_REPO }}"

      - name: "Download image artifacts"
        uses: actions/download-artifact@v4
        with:
          name: image-artifacts

      - name: "Load Docker images"
        run: gzip -dc backend-image.tar.gz | docker load && gzip -dc frontend-image.tar.gz | docker load

      - name: "Login to Amazon ECR (Private and Public)"
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
          | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
          aws ecr-public get-login-password --region us-east-1 \
          | docker login --username AWS --password-stdin public.ecr.aws

      - name: "Ensure Private ECR repos exist (prod)"
        run: |
          set -e
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            aws ecr describe-repositories --repository-names "$repo" >/dev/null 2>&1 \
            || aws ecr create-repository --repository-name "$repo"
          done

      - name: "Detect ECR Public alias + ensure repo (prod)"
        id: ecrpub_prod
        env:
          AWS_REGION: us-east-1
        run: |
          set -e
          ALIAS="$(aws ecr-public describe-registries \
            --region "$AWS_REGION" \
            --query "registries[].aliases[].name | [0]" \
            --output text)"
          if [ -z "$ALIAS" ] || [ "$ALIAS" = "None" ]; then
            echo "::error::No ECR Public alias on this account. Create one in AWS console."
            exit 1
          fi
          echo "alias=$ALIAS" >> "$GITHUB_OUTPUT"

          aws ecr-public get-login-password --region "$AWS_REGION" \
          | docker login --username AWS --password-stdin public.ecr.aws

          aws ecr-public describe-repositories \
            --region "$AWS_REGION" \
            --repository-names "${{ env.OBS_REPO }}" >/dev/null 2>&1 \
          || aws ecr-public create-repository \
               --region "$AWS_REGION" \
               --repository-name "${{ env.OBS_REPO }}"

      - name: "Show detected ECR Public alias (prod)"
        run: |
          echo "Detected alias (output): ${{ steps.ecrpub_prod.outputs.alias }}"
          aws ecr-public describe-registries --region us-east-1 \
            --query "registries[].aliases[].name | [0]" --output text

      - name: "Push App Images to Private ECR (prod)"
        env:
          SHA: ${{ github.sha }}
        run: |
          set -ex
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"

          echo "== Show local images (before tagging) =="
          docker images --format '{{.Repository}}:{{.Tag}}' | sort | uniq | sed -n '1,200p'

          docker tag "${IMAGE_BACKEND_LOCAL}"  "${IMAGE_DEST}:backend-${SHA::12}"
          docker tag "${IMAGE_FRONTEND_LOCAL}" "${IMAGE_DEST}:frontend-${SHA::12}"

          echo "== Show the ECR-tagged images we will push =="
          docker images "${IMAGE_DEST}" --format '{{.Repository}}:{{.Tag}}'

          echo "== Push each tag explicitly =="
          docker push "${IMAGE_DEST}:backend-${SHA::12}"
          docker push "${IMAGE_DEST}:frontend-${SHA::12}"

          echo "== Verify images now exist in ECR (prod) =="
          aws ecr list-images --repository-name "${APP_REPO}" \
            --query 'imageIds[].imageTag' --output text

      - name: "Install cosign"
        uses: sigstore/cosign-installer@v3.6.0

      - name: "Sign Private images"
        env:
          SHA: ${{ github.sha }}
        run: |
          export COSIGN_REPOSITORY="${ECR_REGISTRY}/${SIG_REPO}"
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"
          cosign sign --yes "${IMAGE_DEST}:backend-${SHA::12}"
          cosign sign --yes "${IMAGE_DEST}:frontend-${SHA::12}"

      - name: "Push Observability Stack to Public ECR"
        env:
          AWS_REGION: us-east-1
        run: |
          set -ex
          REG="public.ecr.aws/${{ steps.ecrpub_prod.outputs.alias }}"

          UPSTREAM_PROM="prom/prometheus:${{ env.PROMETHEUS_VERSION }}"
          TARGET_PROM="${REG}/${{ env.OBS_REPO }}:prometheus-${{ env.PROMETHEUS_VERSION }}"
          docker pull "$UPSTREAM_PROM"
          docker tag "$UPSTREAM_PROM" "$TARGET_PROM"
          docker push "$TARGET_PROM"

          UPSTREAM_GRAF="grafana/grafana:${{ env.GRAFANA_VERSION }}"
          TARGET_GRAF="${REG}/${{ env.OBS_REPO }}:grafana-${{ env.GRAFANA_VERSION }}"
          docker pull "$UPSTREAM_GRAF"
          docker tag "$UPSTREAM_GRAF" "$TARGET_GRAF"
          docker push "$TARGET_GRAF"

          UPSTREAM_OTEL="otel/opentelemetry-collector:${{ env.OTELCOL_VERSION }}"
          TARGET_OTEL="${REG}/${{ env.OBS_REPO }}:otelcol-${{ env.OTELCOL_VERSION }}"
          docker pull "$UPSTREAM_OTEL"
          docker tag "$UPSTREAM_OTEL" "$TARGET_OTEL"
          docker push "$TARGET_OTEL"

          UPSTREAM_TEMPO="grafana/tempo:${{ env.TEMPO_VERSION }}"
          TARGET_TEMPO="${REG}/${{ env.OBS_REPO }}:tempo-${{ env.TEMPO_VERSION }}"
          docker pull "$UPSTREAM_TEMPO"
          docker tag "$UPSTREAM_TEMPO" "$TARGET_TEMPO"
          docker push "$TARGET_TEMPO"
