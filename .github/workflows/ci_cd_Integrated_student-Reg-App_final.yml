---
name: "CI/CD (Definitive)"

on:
  workflow_dispatch:
    inputs:
      ECR_PURGE:
        description: >
          Delete & recreate target ECR repos before publish (DANGEROUS)
        required: false
        default: "true"
  push:
    branches: [dev, main, master]
  pull_request:
    branches: ["main", "master"]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write
  packages: write

env:
  PYTHON_VERSION: "3.11"
  AWS_REGION: us-east-1
  ECR_REGISTRY: 724772092393.dkr.ecr.us-east-1.amazonaws.com
  ECR_PURGE: ${{ inputs.ECR_PURGE || secrets.ECR_PURGE || 'true' }}

  # Image names from docker-compose.yml
  PRIVATE_IMAGES: "student-app mysql-db my-flyway-migrations student-frontend"
  PUBLIC_OBS_IMAGES: "infra-otel-collector infra-tempo infra-prometheus infra-grafana infra-loki infra-promtail"

jobs:
  # ----------------------------------------------------------------------------
  # STAGE 1: Continuous Integration (CI)
  # ----------------------------------------------------------------------------
  quality-checks:
    name: "CI: Quality Checks"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: "Set up Python"
        uses: actions/setup-python@v5
        with:
          python-version: "${{ env.PYTHON_VERSION }}"
          cache: pip
          cache-dependency-path: backend/requirements-ci.txt

      - name: "Install tools"
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements-ci.txt

      - name: "Python Lint & Format (ruff)"
        run: |
          ruff check backend/
          ruff format --check backend/

      - name: "Security Lint (bandit)"
        run: bandit -r backend/ || true

      - name: "Dependency Security Scan (pip-audit)"
        run: |
          pip install -r backend/requirements.txt
          pip-audit -r backend/requirements.txt

      - name: "Comprehensive YAML Lint"
        run: yamllint -c .yamllint.yml .

  build-scan-and-artifacts:
    name: "CI: Build ALL Images, Scan & Artifact"
    runs-on: ubuntu-latest
    needs: [quality-checks]
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3

      - name: "Prepare .env for docker-compose (CI)"
        env:
          DB_SECRET: ${{ secrets.DB_SECRET }}
        run: |
          set -e
          mkdir -p infra
          if [ -n "${DB_SECRET:-}" ]; then
            printf "%s\n" "${DB_SECRET}" > infra/.env
          else
            echo "::error::DB_SECRET is not set."
            exit 1
          fi
          # Ensure network var exists for compose interpolation
          if ! grep -q '^DOCKER_NETWORK=' infra/.env; then
            echo "DOCKER_NETWORK=observability-network" >> infra/.env
          fi

      - name: "Build ALL docker-compose images (incl test profile)"
        run: |
          docker compose --env-file infra/.env -f infra/docker-compose.yml --profile test build

      - name: "Install Trivy"
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y wget gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
          sudo apt-get update -y
          sudo apt-get install -y trivy

      - name: "Trivy Scan — ALL service images"
        run: |
          set -e
          SERVICES="app mysql-db flyway frontend otel-collector tempo prometheus grafana loki promtail"
          for s in $SERVICES; do
            IMG="$(docker compose --env-file infra/.env -f infra/docker-compose.yml images -q $s)"
            if [ -z "$IMG" ]; then
              echo "::error::No image found for service $s (check image: in compose)"
              exit 1
            fi
            echo "Scanning $s => $IMG"
            trivy image --severity HIGH,CRITICAL --ignore-unfixed --exit-code 1 "$IMG"
          done

      - name: "Save ALL images as artifact"
        run: |
          set -e
          mkdir -p image_out
          docker save ${{ env.PRIVATE_IMAGES }} ${{ env.PUBLIC_OBS_IMAGES }} | gzip > image_out/all-images.tar.gz

      - name: "Upload image artifact"
        uses: actions/upload-artifact@v4
        with:
          name: image-artifacts
          path: image_out/all-images.tar.gz
          retention-days: 7

  infra-smoke-and-tests:
    name: "CI: Bring up FULL stack + run tests"
    runs-on: ubuntu-latest
    needs: [build-scan-and-artifacts]
    steps:
      - uses: actions/checkout@v4

      - name: "Download image artifact"
        uses: actions/download-artifact@v4
        with:
          name: image-artifacts

      - name: "Load Docker images"
        run: gzip -dc all-images.tar.gz | docker load

      - name: "Prepare .env for docker-compose"
        env:
          DB_SECRET: ${{ secrets.DB_SECRET }}
        run: |
          set -e
          mkdir -p infra
          if [ -n "${DB_SECRET:-}" ]; then
            printf "%s\n" "${DB_SECRET}" > infra/.env
          else
            echo "::error::DB_SECRET is not set."
            exit 1
          fi
          if ! grep -q '^DOCKER_NETWORK=' infra/.env; then
            echo "DOCKER_NETWORK=observability-network" >> infra/.env
          fi

      - name: "Start ALL services (no rebuild)"
        run: |
          docker compose --env-file infra/.env -f infra/docker-compose.yml up -d --no-build

      - name: "Wait for Flyway + app health"
        run: |
          set -e
          echo "Waiting for Flyway migrations..."
          for i in $(seq 1 90); do
            status="$(docker inspect -f '{{.State.Health.Status}}' flyway-migrations 2>/dev/null || echo unknown)"
            if [ "$status" = "healthy" ]; then
              echo "Flyway healthy."
              break
            fi
            if [ "$status" = "unhealthy" ]; then
              echo "::error::Flyway unhealthy."
              docker logs flyway-migrations || true
              exit 1
            fi
            sleep 2
          done

          echo "Waiting for app health..."
          for i in $(seq 1 90); do
            st="$(docker inspect -f '{{.State.Health.Status}}' student-app 2>/dev/null || echo unknown)"
            if [ "$st" = "healthy" ]; then
              echo "App healthy."
              break
            fi
            if [ "$st" = "unhealthy" ]; then
              echo "::error::App unhealthy."
              docker logs student-app || true
              exit 1
            fi
            sleep 2
          done

      - name: "Run backend tests + coverage (profile test)"
        run: |
          mkdir -p coverage
          docker compose --env-file infra/.env -f infra/docker-compose.yml --profile test run --rm \
            -v "$PWD/coverage:/app/coverage" \
            tests \
            pytest --cov=. \
              --cov-report=xml:coverage/coverage.xml \
              --cov-report=html:coverage/htmlcov \
              -v

      - name: "Upload Test & Coverage Artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: test-reports
          path: coverage/
          if-no-files-found: ignore
          retention-days: 7

      - name: "Tear down services"
        if: always()
        run: docker compose --env-file infra/.env -f infra/docker-compose.yml down -v

  open-pr-when-ahead:
    name: "CI: Auto PR dev → default"
    runs-on: ubuntu-latest
    needs: [infra-smoke-and-tests]
    if: success() && github.ref == 'refs/heads/dev' && github.event_name == 'push'
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_TOKEN || github.token }}
          script: |
            const { owner, repo } = context.repo;
            const { data: repoData } = await github.request('GET /repos/{owner}/{repo}', { owner, repo });
            const base = repoData.default_branch;
            const head = 'dev';
            if (base === head) return;

            const { data: prs } = await github.rest.pulls.list({ owner, repo, state: 'open', base, head: `${owner}:${head}` });
            if (prs.length > 0) return;

            try {
              const cmp = await github.request('GET /repos/{owner}/{repo}/compare/{base}...{head}', { owner, repo, base, head });
              if ((cmp.data.ahead_by || 0) === 0) return;
            } catch (e) { return; }

            await github.rest.pulls.create({ owner, repo, head, base, title: `Auto PR: ${head} → ${base}`, body: 'Opened by CI.' });

  # ----------------------------------------------------------------------------
  # STAGE 2: Continuous Deployment (CD)
  # ----------------------------------------------------------------------------
  publish-preprod:
    name: "CD: Deploy to Pre-Prod"
    runs-on: ubuntu-latest
    needs: [infra-smoke-and-tests]
    if: >-
      success() && github.event_name == 'push' && (
        github.ref == 'refs/heads/main' ||
        github.ref == 'refs/heads/master'
      )
    environment: pre-production
    env:
      APP_REPO: mashkenneth/public-student-reg-app/pre-prod
      SIG_REPO: mashkenneth/public-student-reg-app/pre-prod-sig
      OBS_REPO: public-student-reg-app-pre-prod-observability
    steps:
      - name: "Gate: ensure merged PR was from dev"
        id: gate
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const { owner, repo } = context.repo;
            const sha = context.sha;
            const { data: prs } = await github.request(
              'GET /repos/{owner}/{repo}/commits/{ref}/pulls',
              { owner, repo, ref: sha, mediaType: { previews: ['groot'] } }
            );
            const ok = prs.some(pr =>
              pr.merged_at &&
              pr.state === 'closed' &&
              pr.base &&
              (pr.base.ref === 'main' || pr.base.ref === 'master') &&
              pr.head &&
              pr.head.ref === 'dev'
            );
            core.setOutput('ok', ok ? 'true' : 'false');

      - name: "Configure AWS Credentials"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "Sanity check caller identity"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        run: aws sts get-caller-identity

      - name: "(Dangerous) Delete & recreate ECR Private repos"
        if: ${{ steps.gate.outputs.ok == 'true' && env.ECR_PURGE == 'true' }}
        run: |
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            if aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1; then
              aws ecr delete-repository --repository-name "${repo}" --force
            fi
            aws ecr create-repository --repository-name "${repo}"
          done

      - name: "Download image artifact"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        uses: actions/download-artifact@v4
        with:
          name: image-artifacts

      - name: "Load Docker images"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        run: gzip -dc all-images.tar.gz | docker load

      - name: "Login to Amazon ECR (Private and Public)"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
          | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
          aws ecr-public get-login-password --region us-east-1 \
          | docker login --username AWS --password-stdin public.ecr.aws

      - name: "Ensure Private ECR repos exist (preprod)"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        run: |
          set -e
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            aws ecr describe-repositories --repository-names "$repo" >/dev/null 2>&1 \
            || aws ecr create-repository --repository-name "$repo"
          done

      - name: "Detect ECR Public alias (preprod)"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        id: ecrpub_pre
        env:
          AWS_REGION: us-east-1
        run: |
          set -e
          ALIAS="$(aws ecr-public describe-registries \
            --region "$AWS_REGION" \
            --query "registries[].aliases[].name | [0]" \
            --output text)"
          if [ -z "$ALIAS" ] || [ "$ALIAS" = "None" ]; then
            echo "::error::No ECR Public alias on this account. Create one in AWS console."
            exit 1
          fi
          echo "alias=$ALIAS" >> "$GITHUB_OUTPUT"

      - name: "Push PRIVATE images to Private ECR (preprod)"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        env:
          SHA: ${{ github.sha }}
        run: |
          set -ex
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"
          for img in ${{ env.PRIVATE_IMAGES }}; do
            docker tag "${img}:latest" "${IMAGE_DEST}:${img}-${SHA::12}"
            docker push "${IMAGE_DEST}:${img}-${SHA::12}"
          done

      - name: "Install cosign"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        uses: sigstore/cosign-installer@v3.6.0

      - name: "Sign PRIVATE images"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        env:
          SHA: ${{ github.sha }}
        run: |
          export COSIGN_REPOSITORY="${ECR_REGISTRY}/${SIG_REPO}"
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"
          for img in ${{ env.PRIVATE_IMAGES }}; do
            cosign sign --yes "${IMAGE_DEST}:${img}-${SHA::12}"
          done

      - name: "Push OBS images to Public ECR (preprod)"
        if: ${{ steps.gate.outputs.ok == 'true' }}
        env:
          SHA: ${{ github.sha }}
        run: |
          set -ex
          REG="public.ecr.aws/${{ steps.ecrpub_pre.outputs.alias }}"
          for img in ${{ env.PUBLIC_OBS_IMAGES }}; do
            docker tag "${img}:latest" "${REG}/${{ env.OBS_REPO }}:${img}-${SHA::12}"
            docker push "${REG}/${{ env.OBS_REPO }}:${img}-${SHA::12}"
          done

  publish-prod:
    name: "CD: Deploy to Production"
    runs-on: ubuntu-latest
    needs: [infra-smoke-and-tests]
    if: >-
      success() && (
        github.ref == 'refs/heads/main' ||
        github.ref == 'refs/heads/master'
      ) && github.event_name == 'push'
    environment: production
    env:
      APP_REPO: mashkenneth/public-student-reg-app/prod
      SIG_REPO: mashkenneth/public-student-reg-app/prod-sig
      OBS_REPO: public-student-reg-app-prod-observability
    steps:
      - name: "Configure AWS Credentials"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: "Sanity check caller identity"
        run: aws sts get-caller-identity

      - name: "Download image artifact"
        uses: actions/download-artifact@v4
        with:
          name: image-artifacts

      - name: "Load Docker images"
        run: gzip -dc all-images.tar.gz | docker load

      - name: "Login to Amazon ECR (Private and Public)"
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
          | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
          aws ecr-public get-login-password --region us-east-1 \
          | docker login --username AWS --password-stdin public.ecr.aws

      - name: "Detect ECR Public alias (prod)"
        id: ecrpub_prod
        env:
          AWS_REGION: us-east-1
        run: |
          set -e
          ALIAS="$(aws ecr-public describe-registries \
            --region "$AWS_REGION" \
            --query "registries[].aliases[].name | [0]" \
            --output text)"
          if [ -z "$ALIAS" ] || [ "$ALIAS" = "None" ]; then
            echo "::error::No ECR Public alias on this account. Create one in AWS console."
            exit 1
          fi
          echo "alias=$ALIAS" >> "$GITHUB_OUTPUT"

      - name: "Push PRIVATE images to Private ECR (prod)"
        env:
          SHA: ${{ github.sha }}
        run: |
          set -ex
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"
          for img in ${{ env.PRIVATE_IMAGES }}; do
            docker tag "${img}:latest" "${IMAGE_DEST}:${img}-${SHA::12}"
            docker push "${IMAGE_DEST}:${img}-${SHA::12}"
          done

      - name: "Install cosign"
        uses: sigstore/cosign-installer@v3.6.0

      - name: "Sign PRIVATE images"
        env:
          SHA: ${{ github.sha }}
        run: |
          export COSIGN_REPOSITORY="${ECR_REGISTRY}/${SIG_REPO}"
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"
          for img in ${{ env.PRIVATE_IMAGES }}; do
            cosign sign --yes "${IMAGE_DEST}:${img}-${SHA::12}"
          done

      - name: "Push OBS images to Public ECR (prod)"
        env:
          SHA: ${{ github.sha }}
        run: |
          set -ex
          REG="public.ecr.aws/${{ steps.ecrpub_prod.outputs.alias }}"
          for img in ${{ env.PUBLIC_OBS_IMAGES }}; do
            docker tag "${img}:latest" "${REG}/${{ env.OBS_REPO }}:${img}-${SHA::12}"
            docker push "${REG}/${{ env.OBS_REPO }}:${img}-${SHA::12}"
          done
