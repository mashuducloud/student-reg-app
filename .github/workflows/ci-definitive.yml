name: CI/CD (Definitive)

on:
  workflow_dispatch:
    inputs:
      ECR_PURGE:
        description: 'Delete & recreate target ECR repos before publish (DANGEROUS)'
        required: false
        default: 'true'
  push:
    branches: ["dev", "main", "master"]
  pull_request:
    branches: ["dev", "main", "master"]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write
  packages: write

# Global environment variables consolidated from both files
env:
  PYTHON_VERSION: "3.11"
  AWS_REGION: us-east-1
  ECR_REGISTRY: 724772092393.dkr.ecr.us-east-1.amazonaws.com
  ECR_PUBLIC_ALIAS: mashkenneth
  BACKEND_DOCKERFILE: infra/Dockerfile.backend
  FRONTEND_DOCKERFILE: infra/Dockerfile.frontend
  IMAGE_BACKEND_LOCAL: student-backend:ci
  IMAGE_FRONTEND_LOCAL: student-frontend:ci
  ECR_PURGE: ${{ inputs.ECR_PURGE || secrets.ECR_PURGE || 'true' }}
  PROMETHEUS_VERSION: "v2.54.1"
  GRAFANA_VERSION: "11.2.0"
  OTELCOL_VERSION: "0.108.0"
  TEMPO_VERSION: "2.5.0"

jobs:
  # ────────────────────────────────────────────────────────────────────────────
  # STAGE 1: Continuous Integration (CI)
  # ────────────────────────────────────────────────────────────────────────────
  quality-checks:
    name: "CI: Quality Checks"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "${{ env.PYTHON_VERSION }}"
          cache: pip
          cache-dependency-path: backend/requirements-ci.txt
      - name: Install tools
        run: python -m pip install --upgrade pip && pip install -r backend/requirements-ci.txt
      - name: Python Lint & Format (ruff)
        run: |
          ruff check backend/
          ruff format --check backend/
      - name: Security Lint (bandit)
        run: bandit -r backend/ || true
      - name: Dependency Security Scan (pip-audit)
        run: pip install -r backend/requirements.txt && pip-audit -r backend/requirements.txt
      - name: Comprehensive YAML Lint
        run: |
          shopt -s nullglob
          yamllint -d relaxed .github/workflows/*.yml || true
          yamllint -d relaxed *.yml *.yaml || true
          if [[ -d infra ]]; then yamllint -d relaxed infra/*.yml infra/*.yaml || true; fi

  build-and-scan:
    name: "CI: Build, Scan & Create Artifacts"
    runs-on: ubuntu-latest
    needs: [quality-checks]
    timeout-minutes: 25
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3
      - name: Build backend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ env.BACKEND_DOCKERFILE }}
          tags: ${{ env.IMAGE_BACKEND_LOCAL }}
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
      - name: Build frontend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ env.FRONTEND_DOCKERFILE }}
          tags: ${{ env.IMAGE_FRONTEND_LOCAL }}
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
      - name: Trivy Scan — BACKEND
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_BACKEND_LOCAL }}
          severity: 'HIGH,CRITICAL'
          ignore-unfixed: true
          exit-code: 1
      - name: Trivy Scan — FRONTEND
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_FRONTEND_LOCAL }}
          severity: 'HIGH,CRITICAL'
          ignore-unfixed: true
          exit-code: 1
      - name: Save Docker images for subsequent jobs
        run: |
          docker save ${{ env.IMAGE_BACKEND_LOCAL }} > backend-image.tar
          docker save ${{ env.IMAGE_FRONTEND_LOCAL }} > frontend-image.tar
      - name: Upload image artifacts
        uses: actions/upload-artifact@v4
        with:
          name: image-artifacts
          path: |
            backend-image.tar
            frontend-image.tar

  infra-smoke-and-tests:
    name: "CI: Integration Tests & Reports"
    runs-on: ubuntu-latest
    needs: [build-and-scan]
    timeout-minutes: 35
    steps:
      - uses: actions/checkout@v4
      - name: Download image artifacts
        uses: actions/download-artifact@v4
        with:
          name: image-artifacts
      - name: Load Docker images
        run: docker load < backend-image.tar && docker load < frontend-image.tar
      - name: Prepare .env for docker-compose
        env:
          DB_SECRET: ${{ secrets.DB_SECRET }}
        run: |
          set -e; mkdir -p infra;
          if [ -n "${DB_SECRET:-}" ]; then printf "%s\n" "${DB_SECRET}" > infra/.env;
          else echo "::error::DB_SECRET is not set."; exit 1; fi
      - name: Start services using Docker Compose
        run: docker compose -f infra/docker-compose.yml up -d
      - name: Prepare helper scripts
        run: |
          set -e; shopt -s nullglob
          for f in .github/scripts/*.sh; do sed -i 's/\r$//' "$f"; chmod +x "$f"; done
      - name: Wait for services and run health checks
        run: |
          if [ -f ./.github/scripts/health-check.sh ]; then
            bash ./.github/scripts/health-check.sh
          else
            echo "health-check.sh not found, sleeping for 30s as a fallback..."
            sleep 30
          fi
      - name: Verify Prometheus active targets
        run: |
          if [ -f ./.github/scripts/verify-targets.py ]; then
            python ./.github/scripts/verify-targets.py
          else
            echo "verify-targets.py not found; skipping."
          fi
      - name: Run backend tests + coverage
        run: |
          mkdir -p coverage
          docker compose -f infra/docker-compose.yml run --rm \
            -v "$PWD/coverage:/app/coverage" \
            tests \
            pytest --cov=. --cov-report=xml:coverage/coverage.xml --cov-report=html:coverage/htmlcov -v
      - name: Upload Test & Coverage Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: test-reports
          path: |
            coverage/coverage.xml
            coverage/htmlcov/
          if-no-files-found: ignore
      - name: Tear down services
        if: always()
        run: docker compose -f infra/docker-compose.yml down -v

  open-pr-when-ahead:
    name: "CI: Auto PR dev → default"
    runs-on: ubuntu-latest
    needs: [infra-smoke-and-tests]
    if: success() && github.ref == 'refs/heads/dev' && github.event_name == 'push'
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const { owner, repo } = context.repo;
            const { data: repoData } = await github.request('GET /repos/{owner}/{repo}', { owner, repo });
            const base = repoData.default_branch;
            const head = 'dev';
            if (base === head) return;
            const { data: { ahead_by } } = await github.request('GET /repos/{owner}/{repo}/compare/{base}...{head}', { owner, repo, base, head });
            if (ahead_by === 0) return;
            const { data: prs } = await github.rest.pulls.list({ owner, repo, state: 'open', base, head: `${owner}:${head}` });
            if (prs.length > 0) { console.log('PR already exists.'); return; }
            await github.rest.pulls.create({ owner, repo, head, base, title: `Auto PR: ${head} → ${base}`, body: `Opened by CI.` });

  # ────────────────────────────────────────────────────────────────────────────
  # STAGE 2: Continuous Deployment (CD)
  # ────────────────────────────────────────────────────────────────────────────
  publish-preprod:
    name: "CD: Deploy to Pre-Prod"
    runs-on: ubuntu-latest
    needs: [infra-smoke-and-tests]
    if: success() && github.ref == 'refs/heads/dev' && github.event_name == 'push'
    environment: pre-production
    env:
      APP_REPO: mashkenneth/public-student-reg-app/pre-prod
      SIG_REPO: mashkenneth/public-student-reg-app/pre-prod-sig
      OBS_REPO: public-student-reg-app-pre-prod-observability
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region:            ${{ env.AWS_REGION }}
      - name: Sanity check caller identity
        run: aws sts get-caller-identity
      - name: (Dangerous) Delete & recreate ECR repos
        if: env.ECR_PURGE == 'true'
        run: |
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            if aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1; then
              aws ecr delete-repository --repository-name "${repo}" --force
            fi
            aws ecr create-repository --repository-name "${repo}"
          done
      - name: Download image artifacts
        uses: actions/download-artifact@v4
        with: { name: image-artifacts }
      - name: Load Docker images
        run: docker load < backend-image.tar && docker load < frontend-image.tar
      - name: Login to Amazon ECR (Private)
        uses: aws-actions/amazon-ecr-login@v2
      - name: Push App Images to Private ECR
        env: { SHA: ${{ github.sha }} }
        run: |
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"
          docker tag "${IMAGE_BACKEND_LOCAL}" "${IMAGE_DEST}:backend-${SHA::12}"
          docker tag "${IMAGE_FRONTEND_LOCAL}" "${IMAGE_DEST}:frontend-${SHA::12}"
          docker push "${IMAGE_DEST}:backend-${SHA::12}"
          docker push "${IMAGE_DEST}:frontend-${SHA::12}"
      - name: Install cosign for image signing
        uses: sigstore/cosign-installer@v3.6.0
      - name: Sign Private images
        env: { SHA: ${{ github.sha }} }
        run: |
          export COSIGN_REPOSITORY="${ECR_REGISTRY}/${SIG_REPO}"
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"
          cosign sign --yes "${IMAGE_DEST}:backend-${SHA::12}"
          cosign sign --yes "${IMAGE_DEST}:frontend-${SHA::12}"
      - name: Login to Amazon ECR (Public)
        uses: aws-actions/amazon-ecr-login@v2
        with: { registry-type: public }
      - name: Push Observability Stack to Public ECR
        run: |
          set -ex
          REG="public.ecr.aws/${{ env.ECR_PUBLIC_ALIAS }}"
          docker pull prom/prometheus:${{ env.PROMETHEUS_VERSION }}
          docker tag prom/prometheus:${{ env.PROMETHEUS_VERSION }} "${REG}/${{ env.OBS_REPO }}:prometheus-${{ env.PROMETHEUS_VERSION }}"
          docker push "${REG}/${{ env.OBS_REPO }}:prometheus-${{ env.PROMETHEUS_VERSION }}"
          # Repeat for Grafana, OTel, and Tempo...

  publish-prod:
    name: "CD: Deploy to Production"
    runs-on: ubuntu-latest
    needs: [infra-smoke-and-tests]
    if: success() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && github.event_name == 'push'
    environment: production
    env:
      APP_REPO: mashkenneth/public-student-reg-app/prod
      SIG_REPO: mashkenneth/public-student-reg-app/prod-sig
      OBS_REPO: public-student-reg-app-prod-observability
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region:            ${{ env.AWS_REGION }}
      - name: Sanity check caller identity
        run: aws sts get-caller-identity
      - name: (Dangerous) Delete & recreate ECR repos
        if: env.ECR_PURGE == 'true'
        run: |
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            if aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1; then
              aws ecr delete-repository --repository-name "${repo}" --force
            fi
            aws ecr create-repository --repository-name "${repo}"
          done
      - name: Download image artifacts
        uses: actions/download-artifact@v4
        with: { name: image-artifacts }
      - name: Load Docker images
        run: docker load < backend-image.tar && docker load < frontend-image.tar
      - name: Login to Amazon ECR (Private)
        uses: aws-actions/amazon-ecr-login@v2
      - name: Push App Images to Private ECR
        env: { SHA: ${{ github.sha }} }
        run: |
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"
          docker tag "${IMAGE_BACKEND_LOCAL}" "${IMAGE_DEST}:backend-${SHA::12}"
          docker tag "${IMAGE_FRONTEND_LOCAL}" "${IMAGE_DEST}:frontend-${SHA::12}"
          docker push "${IMAGE_DEST}:backend-${SHA::12}"
          docker push "${IMAGE_DEST}:frontend-${SHA::12}"
      - name: Install cosign for image signing
        uses: sigstore/cosign-installer@v3.6.0
      - name: Sign Private images
        env: { SHA: ${{ github.sha }} }
        run: |
          export COSIGN_REPOSITORY="${ECR_REGISTRY}/${SIG_REPO}"
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"
          cosign sign --yes "${IMAGE_DEST}:backend-${SHA::12}"
          cosign sign --yes "${IMAGE_DEST}:frontend-${SHA::12}"
      - name: Login to Amazon ECR (Public)
        uses: aws-actions/amazon-ecr-login@v2
        with: { registry-type: public }
      - name: Push Observability Stack to Public ECR
        run: |
          set -ex
          REG="public.ecr.aws/${{ env.ECR_PUBLIC_ALIAS }}"
          docker pull prom/prometheus:${{ env.PROMETHEUS_VERSION }}
          docker tag prom/prometheus:${{ env.PROMETHEUS_VERSION }} "${REG}/${{ env.OBS_REPO }}:prometheus-${{ env.PROMETHEUS_VERSION }}"
          docker push "${REG}/${{ env.OBS_REPO }}:prometheus-${{ env.PROMETHEUS_VERSION }}"
          # Repeat for Grafana, OTel, and Tempo...
