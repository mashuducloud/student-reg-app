name: CI (Unified Build, Test & Deploy)

on:
  workflow_dispatch:
    inputs:
      ECR_PURGE:
        description: 'Delete & recreate ECR repos before publish (DANGEROUS)'
        required: false
        default: 'true'
  push:
    branches: [ "dev", "main", "master" ]
  pull_request:
    branches: [ "dev", "main", "master" ]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write
  packages: write

env:
  PYTHON_VERSION: "3.11"
  AWS_REGION: us-east-1
  ECR_REGISTRY: 724772092393.dkr.ecr.us-east-1.amazonaws.com
  BACKEND_DOCKERFILE: infra/Dockerfile.backend
  FRONTEND_DOCKERFILE: infra/Dockerfile.frontend
  IMAGE_BACKEND_LOCAL: student-backend:ci
  IMAGE_FRONTEND_LOCAL: student-frontend:ci
  # default true, can be overridden via workflow_dispatch input or secret
  ECR_PURGE: ${{ inputs.ECR_PURGE || secrets.ECR_PURGE || 'true' }}
  PROMETHEUS_VERSION: "v2.54.1"
  GRAFANA_VERSION: "11.2.0"
  OTELCOL_VERSION: "0.108.0"
  TEMPO_VERSION: "2.5.0"

jobs:
  build-test:
    name: Lint • Build • Scan • Test • Artifacts
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip
          cache-dependency-path: |
            requirements.txt
            requirements-ci.txt
            backend/requirements.txt
            backend/requirements-ci.txt

      - name: Install CI toolchain
        run: |
          python -m pip install --upgrade pip
          if [[ -f backend/requirements-ci.txt ]]; then
            pip install -r backend/requirements-ci.txt
          elif [[ -f requirements-ci.txt ]]; then
            pip install -r requirements-ci.txt
          else
            pip install flake8 bandit yamllint pytest
          fi

      - name: Install app dependencies
        run: |
          if [[ -f backend/requirements.txt ]]; then
            pip install -r backend/requirements.txt
          elif [[ -f requirements.txt ]]; then
            pip install -r requirements.txt
          fi

      - name: Python Lint (flake8)
        run: |
          if [[ -d backend ]]; then flake8 backend/; else flake8 .; fi

      - name: Security Lint (bandit — non-blocking)
        run: |
          if [[ -d backend ]]; then bandit -r backend/ || true; else bandit -r . || true; fi

      - name: YAML Lint (observability & workflow)
        run: |
          set -e
          shopt -s nullglob
          yamllint -d relaxed .github/workflows || true
          yamllint -d relaxed *.yml *.yaml || true
          if [[ -d infra ]]; then yamllint -d relaxed infra || true; fi

      - name: Build backend image
        run: |
          docker build -t "${IMAGE_BACKEND_LOCAL}" -f "${BACKEND_DOCKERFILE}" .

      - name: Build frontend image
        run: |
          docker build -t "${IMAGE_FRONTEND_LOCAL}" -f "${FRONTEND_DOCKERFILE}" .

      - name: Trivy Scan — BACKEND
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: ${{ env.IMAGE_BACKEND_LOCAL }}
          severity: HIGH,CRITICAL
          ignore-unfixed: true
          format: table
          exit-code: 1

      - name: Trivy Scan — FRONTEND
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: ${{ env.IMAGE_FRONTEND_LOCAL }}
          severity: HIGH,CRITICAL
          ignore-unfixed: true
          format: table
          exit-code: 1

      - name: Run unit tests (pytest)
        env:
          DB_HOST: 127.0.0.1
          DB_USER: student
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: student_registration_db
          DB_PORT: '3306'
        run: |
          set -e
          if [[ -f backend/test_app.py ]]; then
            pytest -q backend/test_app.py
          elif [[ -f tests/unit/test_app.py ]]; then
            pytest -q tests/unit/test_app.py
          else
            pytest -q
          fi

      - name: Create docker network for tests
        run: docker network create testnet || true

      - name: Start MySQL (ephemeral for CI)
        env:
          MYSQL_DATABASE: student_registration_db
          MYSQL_USER: student
          MYSQL_PASSWORD: ${{ secrets.DB_PASSWORD }}
          MYSQL_ROOT_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          docker run -d --rm --name mysql             --network testnet             -e MYSQL_DATABASE="${MYSQL_DATABASE}"             -e MYSQL_USER="${MYSQL_USER}"             -e MYSQL_PASSWORD="${MYSQL_PASSWORD}"             -e MYSQL_ROOT_PASSWORD="${MYSQL_ROOT_PASSWORD}"             -p 3306:3306             mysql:8.0             --default-authentication-plugin=mysql_native_password

      - name: Wait for MySQL to be healthy
        run: |
          set -e
          for i in {1..60}; do
            docker exec mysql mysqladmin ping -h 127.0.0.1 -uroot -p"${{ secrets.DB_PASSWORD }}" --silent && exit 0 || sleep 2
          done
          echo "MySQL did not become ready in time" >&2
          docker logs mysql || true
          exit 1

      - name: Start app container for integration tests
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          docker run -d --rm --name app             --network testnet             -p 5000:5000 -p 9100:9100             -e DB_HOST=mysql             -e DB_USER=student             -e DB_PASSWORD="${DB_PASSWORD}"             -e DB_NAME=student_registration_db             -e DB_PORT=3306             "${IMAGE_BACKEND_LOCAL}"
          echo "APP_BASE_URL=http://localhost:5000" >> "$GITHUB_ENV"
          echo "METRICS_URL=http://localhost:9100/metrics" >> "$GITHUB_ENV"

      - name: Wait for app to be healthy
        run: |
          set -e
          for i in {1..60}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/health || true)
            if [ "$code" = "200" ]; then
              exit 0
            fi
            sleep 2
          done
          echo "App did not become healthy in time (last code: $code)" >&2
          echo "--- APP LOGS ---"
          docker logs app || true
          echo "--- MYSQL LOGS ---"
          docker logs mysql || true
          exit 1

      - name: Run integration tests
        env:
          APP_BASE_URL: ${{ env.APP_BASE_URL }}
          METRICS_URL:  ${{ env.METRICS_URL }}
        run: |
          pytest -q tests/integration/test_health_e2e.py

      - name: Stop containers
        if: always()
        run: |
          docker rm -f app || true
          docker rm -f mysql || true
          docker network rm testnet || true

      - name: Save Docker images as artifacts
        run: |
          docker save "${IMAGE_BACKEND_LOCAL}" | gzip > backend-image.tar.gz
          docker save "${IMAGE_FRONTEND_LOCAL}" | gzip > frontend-image.tar.gz

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-and-tests
          path: |
            backend-image.tar.gz
            frontend-image.tar.gz
            **/coverage.xml
            coverage/
            .pytest_cache/
          if-no-files-found: ignore

  publish-preprod-app:
    name: Publish App (Pre-Prod) — purge ON
    runs-on: ubuntu-latest
    needs: [build-test]
    if: github.ref == 'refs/heads/dev'
    env:
      APP_REPO: mashkenneth/public-student-reg-app/pre-prod
      SIG_REPO: mashkenneth/public-student-reg-app/pre-prod-student-reg-app-sig
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (static keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Sanity check caller identity
        run: aws sts get-caller-identity

      - name: Cleanup legacy Private repos (Pre-Prod)
        shell: bash
        run: |
          set -euo pipefail
          LEGACY=(
            "mashkenneth/public-student-reg-app/pre-prod-student-reg-app"
            "mashkenneth/public-student-reg-app/pre-prod-student-frontend"
            "mashkenneth/public-student-reg-app/pre-prod-student-frontend-sig"
          )
          for repo in "${LEGACY[@]}"; do
            if aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1; then
              echo "Deleting legacy private repo ${repo} ..."
              aws ecr delete-repository --repository-name "${repo}" --force >/dev/null || true
            fi
          done

      - name: (Dangerous) Delete & recreate ECR repos (Pre-Prod app)
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${ECR_PURGE}" != "true" ]]; then
            echo "ECR_PURGE is not true; skipping destructive purge."
            exit 0
          fi
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            if aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1; then
              echo "Deleting repository ${repo} (force) ..."
              aws ecr delete-repository --repository-name "${repo}" --force >/dev/null
            fi
            echo "Recreating repository ${repo} (MUTABLE, AES256) ..."
            aws ecr create-repository               --repository-name "${repo}"               --image-tag-mutability MUTABLE               --encryption-configuration encryptionType=AES256               >/dev/null
          done

      - name: Download image artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-and-tests

      - name: Load images
        run: |
          docker load -i backend-image.tar.gz
          docker load -i frontend-image.tar.gz

      - name: Login to Amazon ECR (private)
        uses: aws-actions/amazon-ecr-login@v2

      - name: Push to Private ECR (single repo: backend + frontend)
        env:
          SHA: ${{ github.sha }}
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_APP="${ECR_REGISTRY}/${APP_REPO}"

          push_retry() {
            local ref="$1"
            for i in {1..3}; do
              if docker push "$ref"; then
                echo "Pushed: $ref"
                return 0
              fi
              echo "Push failed (attempt $i): $ref"
              sleep 3
            done
            echo "Giving up pushing: $ref" >&2
            return 1
          }

          echo "Target app repo: ${IMAGE_APP}"

          # Backend tags
          docker tag "${IMAGE_BACKEND_LOCAL}" "${IMAGE_APP}:backend-latest"
          docker tag "${IMAGE_BACKEND_LOCAL}" "${IMAGE_APP}:backend-${SHA::12}"

          # Frontend tags
          docker tag "${IMAGE_FRONTEND_LOCAL}" "${IMAGE_APP}:frontend-latest"
          docker tag "${IMAGE_FRONTEND_LOCAL}" "${IMAGE_APP}:frontend-${SHA::12}"

          # Push backend
          push_retry "${IMAGE_APP}:backend-latest"
          push_retry "${IMAGE_APP}:backend-${SHA::12}"

          # Push frontend
          push_retry "${IMAGE_APP}:frontend-latest"
          push_retry "${IMAGE_APP}:frontend-${SHA::12}"

          echo "Done pushing images to ${IMAGE_APP}"

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.6.0

      - name: Sign Private images (cosign keyless)
        env:
          SHA: ${{ github.sha }}
        run: |
          IMAGE_APP="${ECR_REGISTRY}/${APP_REPO}"
          SIG_APP="${ECR_REGISTRY}/${SIG_REPO}"
          # backend
          COSIGN_REPOSITORY="${SIG_APP}" cosign sign --yes "${IMAGE_APP}:backend-latest"
          COSIGN_REPOSITORY="${SIG_APP}" cosign sign --yes "${IMAGE_APP}:backend-${SHA::12}"
          # frontend
          COSIGN_REPOSITORY="${SIG_APP}" cosign sign --yes "${IMAGE_APP}:frontend-latest"
          COSIGN_REPOSITORY="${SIG_APP}" cosign sign --yes "${IMAGE_APP}:frontend-${SHA::12}"

      - name: Verify only two private repos exist (Pre-Prod)
        shell: bash
        run: |
          set -euo pipefail
          ALLOWED=("mashkenneth/public-student-reg-app/pre-prod" "mashkenneth/public-student-reg-app/pre-prod-student-reg-app-sig")
          mapfile -t ALL < <(aws ecr describe-repositories             --query "repositories[?starts_with(repositoryName, \`mashkenneth/public-student-reg-app/\`)].repositoryName"             --output text | tr '	' '
' | sed '/^$/d' || true)
          declare -A OK; for a in "${ALLOWED[@]}"; do OK["$a"]=1; done
          UNEXPECTED=()
          for r in "${ALL[@]:-}"; do [[ -z "${OK[$r]:-}" ]] && UNEXPECTED+=("$r"); done
          if ((${#UNEXPECTED[@]:-0} > 0)); then
            echo "::error::Unexpected repos present:"; printf ' - %s
' "${UNEXPECTED[@]}"; exit 1
          fi
          echo "✅ Exactly the expected two repos exist (Pre-Prod)."

  publish-preprod-infra:
    name: Publish Observability (Pre-Prod Public ECR) — purge ON
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/dev'
    env:
      OBS_REPO_NAME: public-student-reg-app-pre-prod-observability
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (static keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region:            us-east-1

      - name: Sanity check caller identity
        run: aws sts get-caller-identity

      - name: (Dangerous) Delete & recreate ECR Public repo (Pre-Prod infra)
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${ECR_PURGE}" != "true" ]]; then
            echo "ECR_PURGE is not true; skipping destructive purge."
            exit 0
          fi
          if aws ecr-public describe-repositories --repository-names "${OBS_REPO_NAME}" >/dev/null 2>&1; then
            echo "Deleting public repo ${OBS_REPO_NAME} ..."
            aws ecr-public delete-repository --repository-name "${OBS_REPO_NAME}" --force >/dev/null
          fi
          echo "Creating public repo ${OBS_REPO_NAME} ..."
          aws ecr-public create-repository             --repository-name "${OBS_REPO_NAME}"             --catalog-data description="Unified observability images (Pre-Prod)" >/dev/null

      - name: Discover ECR Public endpoint (alias or registryId) and login
        shell: bash
        run: |
          set -euo pipefail
          ALIAS="$(aws ecr-public describe-registries --region us-east-1 --query 'registries[0].registryAlias' --output text 2>/dev/null || true)"
          REGID="$(aws ecr-public describe-registries --region us-east-1 --query 'registries[0].registryId'   --output text 2>/dev/null || true)"
          if [[ -n "${ALIAS}" && "${ALIAS}" != "None" ]]; then
            REG="public.ecr.aws/${ALIAS}"
            echo "Using ECR Public alias: ${ALIAS}"
          elif [[ -n "${REGID}" && "${REGID}" != "None" ]]; then
            REG="public.ecr.aws/${REGID}"
            echo "Alias not set; using registryId: ${REGID}"
          else
            echo "::error::Could not determine ECR Public endpoint (no alias or registryId). Check IAM permissions for ecr-public:DescribeRegistries."
            exit 1
          fi
          echo "REG=${REG}" >> "$GITHUB_ENV"
          aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin "${REG}"

      - name: Pull upstream images
        run: |
          docker pull prom/prometheus:${PROMETHEUS_VERSION}
          docker pull grafana/grafana:${GRAFANA_VERSION}
          docker pull otel/opentelemetry-collector:${OTELCOL_VERSION}
          docker pull grafana/tempo:${TEMPO_VERSION}

      - name: Tag & Push to ECR Public (Pre-Prod)
        shell: bash
        run: |
          set -euo pipefail
          docker tag prom/prometheus:${PROMETHEUS_VERSION}            "${REG}/${OBS_REPO_NAME}:prometheus-${PROMETHEUS_VERSION}"
          docker tag grafana/grafana:${GRAFANA_VERSION}              "${REG}/${OBS_REPO_NAME}:grafana-${GRAFANA_VERSION}"
          docker tag otel/opentelemetry-collector:${OTELCOL_VERSION} "${REG}/${OBS_REPO_NAME}:otelcol-${OTELCOL_VERSION}"
          docker tag grafana/tempo:${TEMPO_VERSION}                  "${REG}/${OBS_REPO_NAME}:tempo-${TEMPO_VERSION}"
          push_retry() { ref="$1"; for i in {1..3}; do docker push "$ref" && return 0; echo "Retry $i: $ref"; sleep 3; done; return 1; }
          push_retry "${REG}/${OBS_REPO_NAME}:prometheus-${PROMETHEUS_VERSION}"
          push_retry "${REG}/${OBS_REPO_NAME}:grafana-${GRAFANA_VERSION}"
          push_retry "${REG}/${OBS_REPO_NAME}:otelcol-${OTELCOL_VERSION}"
          push_retry "${REG}/${OBS_REPO_NAME}:tempo-${TEMPO_VERSION}"

  publish-prod-app:
    name: Publish App (Prod) — purge ON
    runs-on: ubuntu-latest
    needs: [build-test]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    env:
      APP_REPO: mashkenneth/public-student-reg-app/prod
      SIG_REPO: mashkenneth/public-student-reg-app/prod-student-reg-app-sig
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (static keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Sanity check caller identity
        run: aws sts get-caller-identity

      - name: Cleanup legacy Private repos (Prod)
        shell: bash
        run: |
          set -euo pipefail
          LEGACY=(
            "mashkenneth/public-student-reg-app/prod-student-reg-app"
            "mashkenneth/public-student-reg-app/prod-student-frontend"
            "mashkenneth/public-student-reg-app/prod-student-frontend-sig"
          )
          for repo in "${LEGACY[@]}"; do
            if aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1; then
              echo "Deleting legacy private repo ${repo} ..."
              aws ecr delete-repository --repository-name "${repo}" --force >/dev/null || true
            fi
          done

      - name: (Dangerous) Delete & recreate ECR repos (Prod app)
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${ECR_PURGE}" != "true" ]]; then
            echo "ECR_PURGE is not true; skipping destructive purge."
            exit 0
          fi
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            if aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1; then
              echo "Deleting repository ${repo} (force) ..."
              aws ecr delete-repository --repository-name "${repo}" --force >/dev/null
            fi
            echo "Recreating repository ${repo} (MUTABLE, AES256) ..."
            aws ecr create-repository               --repository-name "${repo}"               --image-tag-mutability MUTABLE               --encryption-configuration encryptionType=AES256               >/dev/null
          done

      - name: Download image artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-and-tests

      - name: Load images
        run: |
          docker load -i backend-image.tar.gz
          docker load -i frontend-image.tar.gz

      - name: Login to Amazon ECR (private)
        uses: aws-actions/amazon-ecr-login@v2

      - name: Push to Private ECR (single repo: backend + frontend)
        env:
          SHA: ${{ github.sha }}
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_APP="${ECR_REGISTRY}/${APP_REPO}"

          push_retry() {
            local ref="$1"
            for i in {1..3}; do
              if docker push "$ref"; then
                echo "Pushed: $ref"
                return 0
              fi
              echo "Push failed (attempt $i): $ref"
              sleep 3
            done
            echo "Giving up pushing: $ref" >&2
            return 1
          }

          echo "Target app repo: ${IMAGE_APP}"

          # Backend tags
          docker tag "${IMAGE_BACKEND_LOCAL}" "${IMAGE_APP}:backend-latest"
          docker tag "${IMAGE_BACKEND_LOCAL}" "${IMAGE_APP}:backend-${SHA::12}"

          # Frontend tags
          docker tag "${IMAGE_FRONTEND_LOCAL}" "${IMAGE_APP}:frontend-latest"
          docker tag "${IMAGE_FRONTEND_LOCAL}" "${IMAGE_APP}:frontend-${SHA::12}"

          # Push backend
          push_retry "${IMAGE_APP}:backend-latest"
          push_retry "${IMAGE_APP}:backend-${SHA::12}"

          # Push frontend
          push_retry "${IMAGE_APP}:frontend-latest"
          push_retry "${IMAGE_APP}:frontend-${SHA::12}"

          echo "Done pushing images to ${IMAGE_APP}"

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.6.0

      - name: Sign Private images (cosign keyless)
        env:
          SHA: ${{ github.sha }}
        run: |
          IMAGE_APP="${ECR_REGISTRY}/${APP_REPO}"
          SIG_APP="${ECR_REGISTRY}/${SIG_REPO}"
          # backend
          COSIGN_REPOSITORY="${SIG_APP}" cosign sign --yes "${IMAGE_APP}:backend-latest"
          COSIGN_REPOSITORY="${SIG_APP}" cosign sign --yes "${IMAGE_APP}:backend-${SHA::12}"
          # frontend
          COSIGN_REPOSITORY="${SIG_APP}" cosign sign --yes "${IMAGE_APP}:frontend-latest"
          COSIGN_REPOSITORY="${SIG_APP}" cosign sign --yes "${IMAGE_APP}:frontend-${SHA::12}"

      - name: Verify only two private repos exist (Prod)
        shell: bash
        run: |
          set -euo pipefail
          ALLOWED=("mashkenneth/public-student-reg-app/prod" "mashkenneth/public-student-reg-app/prod-student-reg-app-sig")
          mapfile -t ALL < <(aws ecr describe-repositories             --query "repositories[?starts_with(repositoryName, \`mashkenneth/public-student-reg-app/\`)].repositoryName"             --output text | tr '	' '
' | sed '/^$/d' || true)
          declare -A OK; for a in "${ALLOWED[@]}"; do OK["$a"]=1; done
          UNEXPECTED=()
          for r in "${ALL[@]:-}"; do [[ -z "${OK[$r]:-}" ]] && UNEXPECTED+=("$r"); done
          if ((${#UNEXPECTED[@]:-0} > 0)); then
            echo "::error::Unexpected repos present:"; printf ' - %s
' "${UNEXPECTED[@]}"; exit 1
          fi
          echo "✅ Exactly the expected two repos exist (Prod)."

  publish-prod-infra:
    name: Publish Observability (Prod Public ECR) — purge ON
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    env:
      OBS_REPO_NAME: public-student-reg-app-prod-observability
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (static keys)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region:            us-east-1

      - name: Sanity check caller identity
        run: aws sts get-caller-identity

      - name: (Dangerous) Delete & recreate ECR Public repo (Prod infra)
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${ECR_PURGE}" != "true" ]]; then
            echo "ECR_PURGE is not true; skipping destructive purge."
            exit 0
          fi
          if aws ecr-public describe-repositories --repository-names "${OBS_REPO_NAME}" >/dev/null 2>&1; then
            echo "Deleting public repo ${OBS_REPO_NAME} ..."
            aws ecr-public delete-repository --repository-name "${OBS_REPO_NAME}" --force >/dev/null
          fi
          echo "Creating public repo ${OBS_REPO_NAME} ..."
          aws ecr-public create-repository             --repository-name "${OBS_REPO_NAME}"             --catalog-data description="Unified observability images (Prod)" >/dev/null

      - name: Discover ECR Public endpoint (alias or registryId) and login
        shell: bash
        run: |
          set -euo pipefail
          ALIAS="$(aws ecr-public describe-registries --region us-east-1 --query 'registries[0].registryAlias' --output text 2>/dev/null || true)"
          REGID="$(aws ecr-public describe-registries --region us-east-1 --query 'registries[0].registryId'   --output text 2>/dev/null || true)"
          if [[ -n "${ALIAS}" && "${ALIAS}" != "None" ]]; then
            REG="public.ecr.aws/${ALIAS}"
            echo "Using ECR Public alias: ${ALIAS}"
          elif [[ -n "${REGID}" && "${REGID}" != "None" ]]; then
            REG="public.ecr.aws/${REGID}"
            echo "Alias not set; using registryId: ${REGID}"
          else
            echo "::error::Could not determine ECR Public endpoint (no alias or registryId). Check IAM permissions for ecr-public:DescribeRegistries."
            exit 1
          fi
          echo "REG=${REG}" >> "$GITHUB_ENV"
          aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin "${REG}"

      - name: Pull upstream images
        run: |
          docker pull prom/prometheus:${PROMETHEUS_VERSION}
          docker pull grafana/grafana:${GRAFANA_VERSION}
          docker pull otel/opentelemetry-collector:${OTELCOL_VERSION}
          docker pull grafana/tempo:${TEMPO_VERSION}

      - name: Tag & Push to ECR Public (Prod)
        shell: bash
        run: |
          set -euo pipefail
          docker tag prom/prometheus:${PROMETHEUS_VERSION}            "${REG}/${OBS_REPO_NAME}:prometheus-${PROMETHEUS_VERSION}"
          docker tag grafana/grafana:${GRAFANA_VERSION}              "${REG}/${OBS_REPO_NAME}:grafana-${GRAFANA_VERSION}"
          docker tag otel/opentelemetry-collector:${OTELCOL_VERSION} "${REG}/${OBS_REPO_NAME}:otelcol-${OTELCOL_VERSION}"
          docker tag grafana/tempo:${TEMPO_VERSION}                  "${REG}/${OBS_REPO_NAME}:tempo-${TEMPO_VERSION}"
          push_retry() { ref="$1"; for i in {1..3}; do docker push "$ref" && return 0; echo "Retry $i: $ref"; sleep 3; done; return 1; }
          push_retry "${REG}/${OBS_REPO_NAME}:prometheus-${PROMETHEUS_VERSION}"
          push_retry "${REG}/${OBS_REPO_NAME}:grafana-${GRAFANA_VERSION}"
          push_retry "${REG}/${OBS_REPO_NAME}:otelcol-${OTELCOL_VERSION}"
          push_retry "${REG}/${OBS_REPO_NAME}:tempo-${TEMPO_VERSION}"
