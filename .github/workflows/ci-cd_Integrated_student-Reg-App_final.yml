---
name: CI/CD (Integrated Final)

on:
  workflow_dispatch:
    inputs:
      ECR_PURGE:
        description: >
          Delete & recreate target ECR repos before publish (DANGEROUS)
        required: false
        default: 'false'
  push:
    branches: ["dev", "main", "master"]
  pull_request:
    branches: ["dev", "main", "master"]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write
  packages: write

env:
  PYTHON_VERSION: "3.11"
  AWS_REGION: us-east-1
  ECR_REGISTRY: 724772092393.dkr.ecr.us-east-1.amazonaws.com
  ECR_PUBLIC_ALIAS: mashkenneth
  BACKEND_DOCKERFILE: infra/Dockerfile.backend
  FRONTEND_DOCKERFILE: infra/Dockerfile.frontend
  IMAGE_BACKEND_LOCAL: student-backend:ci
  IMAGE_FRONTEND_LOCAL: student-frontend:ci
  ECR_PURGE: ${{ inputs.ECR_PURGE || secrets.ECR_PURGE || 'false' }}
  PROMETHEUS_VERSION: "v2.54.1"
  GRAFANA_VERSION: "11.2.0"
  OTELCOL_VERSION: "0.108.0"
  TEMPO_VERSION: "2.5.0"

jobs:
  quality-checks:
    name: "CI: Quality Checks"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "${{ env.PYTHON_VERSION }}"
          cache: pip
          cache-dependency-path: backend/requirements-ci.txt

      - name: Install tools
        run: |
          set -e
          python -m pip install --upgrade pip
          pip install -r backend/requirements-ci.txt
          pip install pip-audit bandit yamllint

      - name: Cache pre-commit envs
        uses: actions/cache@v4
        with:
          path: ~/.cache/pre-commit
          key: pre-commit-${{ runner.os }}-${{ hashFiles('.pre-commit-config.yaml') }}
          restore-keys: |
            pre-commit-${{ runner.os }}-

      - name: Ruff Lint (pre-commit)
        uses: pre-commit/action@v3.0.1
        with:
          extra_args: "ruff --all-files"

      - name: Ruff Format Check (pre-commit)
        uses: pre-commit/action@v3.0.1
        with:
          extra_args: "ruff-format --all-files"

      - name: Security Lint (bandit)
        run: bandit -r backend/ || true

      - name: Dependency Security Scan (pip-audit)
        run: |
          set -e
          pip install -r backend/requirements.txt
          pip-audit -r backend/requirements.txt

      - name: Comprehensive YAML Lint
        run: yamllint .

  build-and-scan:
    name: "CI: Build, Scan & Artifacts"
    runs-on: ubuntu-latest
    needs: [quality-checks]
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-buildx-action@v3

      - name: Build backend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ env.BACKEND_DOCKERFILE }}
          tags: ${{ env.IMAGE_BACKEND_LOCAL }}
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build frontend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ env.FRONTEND_DOCKERFILE }}
          tags: ${{ env.IMAGE_FRONTEND_LOCAL }}
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Trivy Scan ÃƒÆ’Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã‚Â¬Ãƒâ€š BACKEND
        uses: aquasecurity/trivy-action@0.18.0
        with:
          image-ref: ${{ env.IMAGE_BACKEND_LOCAL }}
          severity: 'HIGH,CRITICAL'
          ignore-unfixed: true
          exit-code: 1

      - name: Trivy Scan ÃƒÆ’Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã‚Â¬Ãƒâ€š FRONTEND
        uses: aquasecurity/trivy-action@0.18.0
        with:
          image-ref: ${{ env.IMAGE_FRONTEND_LOCAL }}
          severity: 'HIGH,CRITICAL'
          ignore-unfixed: true
          exit-code: 1

      - name: Save Docker images for subsequent jobs
        run: |
          docker save ${{ env.IMAGE_BACKEND_LOCAL }} > backend-image.tar
          docker save ${{ env.IMAGE_FRONTEND_LOCAL }} > frontend-image.tar

      - name: Upload image artifacts
        uses: actions/upload-artifact@v4
        with:
          name: image-artifacts
          path: |
            backend-image.tar
            frontend-image.tar

  infra-smoke-and-tests:
    name: "CI: Integration Tests & Reports"
    runs-on: ubuntu-latest
    needs: [build-and-scan]
    steps:
      - uses: actions/checkout@v4

      - name: Download image artifacts
        uses: actions/download-artifact@v4
        with:
          name: image-artifacts

      - name: Load Docker images
        run: docker load < backend-image.tar && docker load < frontend-image.tar

      - name: Prepare .env for docker-compose
        env:
          DB_SECRET: ${{ secrets.DB_SECRET }}
        run: |
          set -e
          mkdir -p infra
          if [ -n "${DB_SECRET:-}" ]; then
            printf "%s\n" "${DB_SECRET}" > infra/.env
          else
            echo "::error::DB_SECRET is not set."
            exit 1
          fi

      - name: Start services using Docker Compose
        run: docker compose -f infra/docker-compose.yml up -d

      - name: Normalize shell scripts (CRLF ÃƒÆ’Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã‚Â¬ÃƒÂ¢Ã‚Â¢ LF) + chmod
        shell: bash
        run: bash .github/scripts/fix-crlf.sh || true

      - name: Wait for services and run health checks
        run: |
          if [ -f ./.github/scripts/health-check.sh ]; then
            bash ./.github/scripts/health-check.sh
          else
            echo "health-check.sh not found, sleeping for 30s as a fallback..."
            sleep 30
          fi

      - name: Run backend tests + coverage
        run: |
          mkdir -p coverage
          docker compose -f infra/docker-compose.yml run --rm \
            -v "$PWD/coverage:/app/coverage" \
            tests \
            pytest --cov=. \
            --cov-report=xml:coverage/coverage.xml \
            --cov-report=html:coverage/htmlcov -v

      - name: Upload Test & Coverage Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: test-reports
          path: coverage/
          if-no-files-found: ignore

      - name: Tear down services
        if: always()
        run: docker compose -f infra/docker-compose.yml down -v

  open-pr-when-ahead:
    name: "CI: Auto PR dev ÃƒÆ’Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã‚Â¬ÃƒÂ¢Ã‚Â¢ default"
    runs-on: ubuntu-latest
    needs: [infra-smoke-and-tests]
    if: success() && github.ref == 'refs/heads/dev' && github.event_name == 'push'
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const core = require('@actions/core');
            const { owner, repo } = context.repo;
            const repoData = await github.request(
              'GET /repos/{owner}/{repo}', { owner, repo }
            );
            const base = repoData.data.default_branch;
            const head = 'dev';
            if (base === head) {
              core.info('Default branch equals dev; nothing to do.');
              return;
            }
            const compare = await github.request(
              'GET /repos/{owner}/{repo}/compare/{base}...{head}',
              { owner, repo, base, head }
            );
            if (compare.data.ahead_by === 0) {
              core.info('dev is not ahead; no PR needed.');
              return;
            }
            const prs = await github.rest.pulls.list({
              owner, repo, state: 'open', base, head: `${owner}:${head}`
            });
            if (prs.data.length > 0) {
              core.info('PR already exists.');
              return;
            }
            await github.rest.pulls.create({
              owner, repo, head, base,
              title: `Auto PR: ${head} ÃƒÆ’Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã‚Â¬ÃƒÂ¢Ã‚Â¢ ${base}`,
              body: 'Opened by CI.'
            });

  publish-preprod:
    name: "CD: Deploy to Pre-Prod"
    runs-on: ubuntu-latest
    needs: [infra-smoke-and-tests]
    if: success() && github.ref == 'refs/heads/dev' && github.event_name == 'push'
    environment: pre-production
    env:
      APP_REPO: mashkenneth/public-student-reg-app/pre-prod
      SIG_REPO: mashkenneth/public-student-reg-app/pre-prod-sig
      OBS_REPO: public-student-reg-app-pre-prod-observability
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Sanity check caller identity
        run: aws sts get-caller-identity

      - name: (Dangerous) Delete & recreate ECR Private repos
        if: env.ECR_PURGE == 'true'
        run: |
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            aws ecr delete-repository --repository-name "${repo}" --force || true
            aws ecr create-repository --repository-name "${repo}" || true
          done

      - name: Ensure Private ECR repos exist
        if: env.ECR_PURGE != 'true'
        run: |
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1 \
              || aws ecr create-repository --repository-name "${repo}"
          done

      - name: Apply ECR Lifecycle Policies (private repos, if files exist)
        run: |
          set -e
          for pair in "APP_REPO app-lifecycle.json" "SIG_REPO sig-lifecycle.json"; do
            REPO_VAR=$(echo "$pair" | awk '{print $1}')
            FILE=$(echo "$pair" | awk '{print $2}')
            REPO_NAME="${!REPO_VAR}"
            POLICY_PATH=".github/workflows/ecr-policies/${FILE}"
            if [ -f "$POLICY_PATH" ]; then
              echo "Applying lifecycle policy to $REPO_NAME from $POLICY_PATH"
              aws ecr put-lifecycle-policy \
                --repository-name "$REPO_NAME" \
                --lifecycle-policy-text "file://$POLICY_PATH"
            else
              echo "Policy file not found: $POLICY_PATH (skipping)"
            fi
          done

      - name: (Dangerous) Delete & recreate ECR Public repo
        if: env.ECR_PURGE == 'true'
        run: |
          aws ecr-public delete-repository --repository-name "${{ env.OBS_REPO }}" --force || true
          aws ecr-public create-repository --repository-name "${{ env.OBS_REPO }}" || true

      - name: Ensure Public ECR repo exists + login (Quick sanity check)
        run: |
          set -ex
          aws ecr-public get-login-password --region us-east-1 | \
            docker login \
              --username AWS \
              --password-stdin public.ecr.aws
          aws ecr-public describe-repositories \
            --repository-names "${{ env.OBS_REPO }}" >/dev/null 2>&1 \
            || aws ecr-public create-repository \
              --repository-name "${{ env.OBS_REPO }}"
          echo "Public repo is ready: ${{ env.OBS_REPO }}"

      - name: Download image artifacts
        uses: actions/download-artifact@v4
        with:
          name: image-artifacts

      - name: Load Docker images
        run: docker load < backend-image.tar && docker load < frontend-image.tar

      - name: Login to Amazon ECR (Private)
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login \
              --username AWS \
              --password-stdin ${{ env.ECR_REGISTRY }}

      - name: Push App Images to Private ECR
        env:
          SHA: ${{ github.sha }}
        run: |
          set -e
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"

          BACKEND_TAG="backend-${SHA::12}"
          FRONTEND_TAG="frontend-${SHA::12}"

          BACKEND_URI="${IMAGE_DEST}:${BACKEND_TAG}"
          FRONTEND_URI="${IMAGE_DEST}:${FRONTEND_TAG}"

          echo "Tagging and pushing backend image: ${BACKEND_URI}"
          docker tag "${IMAGE_BACKEND_LOCAL}" "${BACKEND_URI}"
          docker push "${BACKEND_URI}"

          echo "Tagging and pushing frontend image: ${FRONTEND_URI}"
          docker tag "${IMAGE_FRONTEND_LOCAL}" "${FRONTEND_URI}"
          docker push "${FRONTEND_URI}"

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.6.0

      - name: Sign Private images
        env:
          SHA: ${{ github.sha }}
        run: |
          export COSIGN_REPOSITORY="${ECR_REGISTRY}/${SIG_REPO}"
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"

          BACKEND_IMAGE_URI="${IMAGE_DEST}:backend-${SHA::12}" # yamllint disable-line rule:line-length
          FRONTEND_IMAGE_URI="${IMAGE_DEST}:frontend-${SHA::12}" # yamllint disable-line rule:line-length

          echo "Signing backend image: ${BACKEND_IMAGE_URI}"
          cosign sign --yes "${BACKEND_IMAGE_URI}"

          echo "Signing frontend image: ${FRONTEND_IMAGE_URI}"
          cosign sign --yes "${FRONTEND_IMAGE_URI}"

      - name: Push Observability Stack to Public ECR
        run: |
          set -ex
          REPO_PATH="public.ecr.aws/${{ env.ECR_PUBLIC_ALIAS }}/${{ env.OBS_REPO }}"

          # Define images in a loop-friendly format: "name upstream_repo version"
          IMAGES="
          prometheus prom/prometheus ${{ env.PROMETHEUS_VERSION }}
          grafana grafana/grafana ${{ env.GRAFANA_VERSION }}
          otelcol otel/opentelemetry-collector ${{ env.OTELCOL_VERSION }}
          tempo grafana/tempo ${{ env.TEMPO_VERSION }}
          "

          echo "${IMAGES}" | while read -r name upstream_repo version; do
            if [ -n "$name" ]; then
              UPSTREAM_IMAGE="${upstream_repo}:${version}"
              TARGET_IMAGE="${REPO_PATH}:${name}-${version}"

              echo "--- Processing ${TARGET_IMAGE} ---"
              docker pull "${UPSTREAM_IMAGE}"
              docker tag "${UPSTREAM_IMAGE}" "${TARGET_IMAGE}"
              docker push "${TARGET_IMAGE}"
            fi
          done

  publish-prod:
    name: "CD: Deploy to Production"
    runs-on: ubuntu-latest
    needs: [infra-smoke-and-tests]
    if: success() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && github.event_name == 'push'
    environment: production
    env:
      APP_REPO: mashkenneth/public-student-reg-app/prod
      SIG_REPO: mashkenneth/public-student-reg-app/prod-sig
      OBS_REPO: public-student-reg-app-prod-observability
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Sanity check caller identity
        run: aws sts get-caller-identity

      - name: (Dangerous) Delete & recreate ECR Private repos
        if: env.ECR_PURGE == 'true'
        run: |
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            aws ecr delete-repository --repository-name "${repo}" --force || true
            aws ecr create-repository --repository-name "${repo}" || true
          done

      - name: Ensure Private ECR repos exist
        if: env.ECR_PURGE != 'true'
        run: |
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1 \
              || aws ecr create-repository --repository-name "${repo}"
          done

      - name: Apply ECR Lifecycle Policies (private repos, if files exist)
        run: |
          set -e
          for pair in "APP_REPO app-lifecycle.json" "SIG_REPO sig-lifecycle.json"; do
            REPO_VAR=$(echo "$pair" | awk '{print $1}')
            FILE=$(echo "$pair" | awk '{print $2}')
            REPO_NAME="${!REPO_VAR}"
            POLICY_PATH=".github/workflows/ecr-policies/${FILE}"
            if [ -f "$POLICY_PATH" ]; then
              echo "Applying lifecycle policy to $REPO_NAME from $POLICY_PATH"
              aws ecr put-lifecycle-policy \
                --repository-name "$REPO_NAME" \
                --lifecycle-policy-text "file://$POLICY_PATH"
            else
              echo "Policy file not found: $POLICY_PATH (skipping)"
            fi
          done

      - name: (Dangerous) Delete & recreate ECR Public repo
        if: env.ECR_PURGE == 'true'
        run: |
          aws ecr-public delete-repository --repository-name "${{ env.OBS_REPO }}" --force || true
          aws ecr-public create-repository --repository-name "${{ env.OBS_REPO }}" || true

      - name: Ensure Public ECR repo exists + login (Quick sanity check)
        run: |
          set -ex
          aws ecr-public get-login-password --region us-east-1 | \
            docker login \
              --username AWS \
              --password-stdin public.ecr.aws
          aws ecr-public describe-repositories \
            --repository-names "${{ env.OBS_REPO }}" >/dev/null 2>&1 \
            || aws ecr-public create-repository \
              --repository-name "${{ env.OBS_REPO }}"
          echo "Public repo is ready: ${{ env.OBS_REPO }}"

      - name: Download image artifacts
        uses: actions/download-artifact@v4
        with:
          name: image-artifacts

      - name: Load Docker images
        run: docker load < backend-image.tar && docker load < frontend-image.tar

      - name: Login to Amazon ECR (Private)
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login \
              --username AWS \
              --password-stdin ${{ env.ECR_REGISTRY }}

      - name: Push App Images to Private ECR
        env:
          SHA: ${{ github.sha }}
        run: |
          set -e
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"

          BACKEND_TAG="backend-${SHA::12}"
          FRONTEND_TAG="frontend-${SHA::12}"

          BACKEND_URI="${IMAGE_DEST}:${BACKEND_TAG}"
          FRONTEND_URI="${IMAGE_DEST}:${FRONTEND_TAG}"

          echo "Tagging and pushing backend image: ${BACKEND_URI}"
          docker tag "${IMAGE_BACKEND_LOCAL}" "${BACKEND_URI}"
          docker push "${BACKEND_URI}"

          echo "Tagging and pushing frontend image: ${FRONTEND_URI}"
          docker tag "${IMAGE_FRONTEND_LOCAL}" "${FRONTEND_URI}"
          docker push "${FRONTEND_URI}"

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.6.0

      - name: Sign Private images
        env:
          SHA: ${{ github.sha }}
        run: |
          export COSIGN_REPOSITORY="${ECR_REGISTRY}/${SIG_REPO}"
          IMAGE_DEST="${ECR_REGISTRY}/${APP_REPO}"

          BACKEND_IMAGE_URI="${IMAGE_DEST}:backend-${SHA::12}" # yamllint disable-line rule:line-length
          FRONTEND_IMAGE_URI="${IMAGE_DEST}:frontend-${SHA::12}" # yamllint disable-line rule:line-length

          echo "Signing backend image: ${BACKEND_IMAGE_URI}"
          cosign sign --yes "${BACKEND_IMAGE_URI}"

          echo "Signing frontend image: ${FRONTEND_IMAGE_URI}"
          cosign sign --yes "${FRONTEND_IMAGE_URI}"

      - name: Push Observability Stack to Public ECR
        run: |
          set -ex
          REPO_PATH="public.ecr.aws/${{ env.ECR_PUBLIC_ALIAS }}/${{ env.OBS_REPO }}"

          # Define images in a loop-friendly format: "name upstream_repo version"
          IMAGES="
          prometheus prom/prometheus ${{ env.PROMETHEUS_VERSION }}
          grafana grafana/grafana ${{ env.GRAFANA_VERSION }}
          otelcol otel/opentelemetry-collector ${{ env.OTELCOL_VERSION }}
          tempo grafana/tempo ${{ env.TEMPO_VERSION }}
          "

          echo "${IMAGES}" | while read -r name upstream_repo version; do
            if [ -n "$name" ]; then
              UPSTREAM_IMAGE="${upstream_repo}:${version}"
              TARGET_IMAGE="${REPO_PATH}:${name}-${version}"

              echo "--- Processing ${TARGET_IMAGE} ---"
              docker pull "${UPSTREAM_IMAGE}"
              docker tag "${UPSTREAM_IMAGE}" "${TARGET_IMAGE}"
              docker push "${TARGET_IMAGE}"
            fi
          done
