name: CI (Unified Build, Test & Deploy)

on:
  workflow_dispatch:
    inputs:
      ECR_PURGE:
        description: 'Delete & recreate target ECR repos before publish (DANGEROUS)'
        required: false
        default: 'true'   # default ON
  push:
    branches: ["dev", "main", "master"]
  pull_request:
    branches: ["dev", "main", "master"]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write
  packages: write

env:
  PYTHON_VERSION: "3.11"
  AWS_REGION: us-east-1
  ECR_REGISTRY: 724772092393.dkr.ecr.us-east-1.amazonaws.com
  ECR_PUBLIC_ALIAS: mashkenneth
  BACKEND_DOCKERFILE: infra/Dockerfile.backend
  IMAGE_NAME_LOCAL: student-backend:ci
  # Default ON unless overridden by input or secret
  ECR_PURGE: ${{ inputs.ECR_PURGE || secrets.ECR_PURGE || 'true' }}
  # Observability versions (override if needed)
  PROMETHEUS_VERSION: "v2.54.1"
  GRAFANA_VERSION: "11.2.0"
  OTELCOL_VERSION: "0.108.0"
  TEMPO_VERSION: "2.5.0"

jobs:
  build-test:
    name: Lint • Build • Unit & Integration Tests • Artifacts
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip
          cache-dependency-path: |
            requirements.txt
            requirements-ci.txt
            backend/requirements.txt
            backend/requirements-ci.txt

      - name: Install CI toolchain
        run: |
          python -m pip install --upgrade pip
          if [[ -f backend/requirements-ci.txt ]]; then
            pip install -r backend/requirements-ci.txt
          elif [[ -f requirements-ci.txt ]]; then
            pip install -r requirements-ci.txt
          else
            pip install flake8 bandit yamllint pytest
          fi

      - name: Install app dependencies
        run: |
          if [[ -f backend/requirements.txt ]]; then
            pip install -r backend/requirements.txt
          elif [[ -f requirements.txt ]]; then
            pip install -r requirements.txt
          fi

      # Lint + YAML Config
      - name: Lint (flake8)
        run: |
          if [[ -d backend ]]; then flake8 backend/; else flake8 .; fi

      - name: Security Lint (bandit — non-blocking)
        run: |
          if [[ -d backend ]]; then bandit -r backend/ || true; else bandit -r . || true; fi

      - name: YAML Lint
        run: |
          set -e
          shopt -s nullglob
          yamllint -d relaxed .github/workflows || true
          yamllint -d relaxed *.yml *.yaml || true
          if [[ -d infra ]]; then yamllint -d relaxed infra || true; fi

      # Build
      - name: Build backend image
        run: |
          docker build -t "${IMAGE_NAME_LOCAL}" -f "${BACKEND_DOCKERFILE}" .

      # Unit Tests (original CI's DB env pattern; no DB service required)
      - name: Run unit tests (pytest)
        env:
          DB_HOST: 127.0.0.1
          DB_USER: student
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: student_registration_db
          DB_PORT: '3306'
        run: |
          set -e
          if [[ -f backend/test_app.py ]]; then
            pytest -q backend/test_app.py
          elif [[ -f tests/unit/test_app.py ]]; then
            pytest -q tests/unit/test_app.py
          else
            pytest -q
          fi

      # Integration Tests
      - name: Start container for integration tests
        run: |
          docker run -d --rm --name app \
            -p 5000:5000 -p 9100:9100 \
            -e DB_HOST=127.0.0.1 \
            -e DB_USER=student \
            -e DB_PASSWORD="${{ secrets.DB_PASSWORD }}" \
            -e DB_NAME=student_registration_db \
            -e DB_PORT=3306 \
            "${IMAGE_NAME_LOCAL}"
          echo "APP_BASE_URL=http://localhost:5000" >> "$GITHUB_ENV"
          echo "METRICS_URL=http://localhost:9100/metrics" >> "$GITHUB_ENV"

      - name: Wait for app to be healthy
        run: |
          set -e
          for i in {1..30}; do
            curl -fsS http://localhost:5000/health && exit 0 || sleep 1
          done
          echo "App did not become healthy in time" >&2
          exit 1

      - name: Run integration tests
        env:
          APP_BASE_URL: ${{ env.APP_BASE_URL }}
          METRICS_URL:  ${{ env.METRICS_URL }}
        run: |
          pytest -q tests/integration/test_health_e2e.py

      - name: Stop container
        if: always()
        run: docker rm -f app || true

      # Publish Build Artifacts
      - name: Save Docker image as artifact (tar.gz)
        run: |
          docker save "${IMAGE_NAME_LOCAL}" | gzip > app-image.tar.gz
        if: ${{ !cancelled() }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        if: ${{ !cancelled() }}
        with:
          name: build-and-tests
          path: |
            app-image.tar.gz
            **/coverage.xml
            coverage/
            .pytest_cache/
          if-no-files-found: ignore

  publish-preprod-app:
    name: Publish App (Pre-Prod) — purge ON
    runs-on: ubuntu-latest
    needs: [build-test]
    if: github.ref == 'refs/heads/dev'
    env:
      APP_REPO: mashkenneth/public-student-reg-app/pre-prod-student-reg-app
      SIG_REPO: mashkenneth/public-student-reg-app/pre-prod-student-reg-app-sig
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region:            us-east-1

      - name: Sanity check caller identity
        run: aws sts get-caller-identity

      - name: (Dangerous) Delete & recreate ECR repos (Pre-Prod app)
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${ECR_PURGE}" != "true" ]]; then
            echo "ECR_PURGE is not true; skipping destructive purge."
            exit 0
          fi
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            if aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1; then
              echo "Deleting repository ${repo} (force) ..."
              aws ecr delete-repository --repository-name "${repo}" --force >/dev/null
            fi
            echo "Recreating repository ${repo} (MUTABLE, AES256) ..."
            aws ecr create-repository \
              --repository-name "${repo}" \
              --image-tag-mutability MUTABLE \
              --encryption-configuration encryptionType=AES256 \
              >/dev/null
          done

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: build-and-tests

      - name: Load image
        run: docker load -i app-image.tar.gz

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Push to Pre-Prod app repo
        env:
          SHA: ${{ github.sha }}
        run: |
          IMAGE="${ECR_REGISTRY}/${APP_REPO}"
          docker tag "${IMAGE_NAME_LOCAL}" "${IMAGE}:latest"
          docker tag "${IMAGE_NAME_LOCAL}" "${IMAGE}:${SHA::12}"
          docker push "${IMAGE}:latest"
          docker push "${IMAGE}:${SHA::12}"

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.6.0

      - name: Sign Pre-Prod app images (cosign keyless)
        env:
          SHA: ${{ github.sha }}
        run: |
          IMAGE="${ECR_REGISTRY}/${APP_REPO}"
          COSIGN_REPOSITORY="${ECR_REGISTRY}/${SIG_REPO}" cosign sign --yes "${IMAGE}:latest"
          COSIGN_REPOSITORY="${ECR_REGISTRY}/${SIG_REPO}" cosign sign --yes "${IMAGE}:${SHA::12}"

  publish-preprod-infra:
    name: Publish Observability (Pre-Prod Public ECR) — purge ON
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/dev'
    env:
      OBS_REPO: mashkenneth/public-student-reg-app/pre-prod-observability
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region:            us-east-1

      - name: Sanity check caller identity
        run: aws sts get-caller-identity

      - name: (Dangerous) Delete & recreate ECR Public repo (Pre-Prod infra)
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${ECR_PURGE}" != "true" ]]; then
            echo "ECR_PURGE is not true; skipping destructive purge."
            exit 0
          fi
          if aws ecr-public describe-repositories --repository-names "${OBS_REPO}" >/dev/null 2>&1; then
            echo "Deleting public repo ${OBS_REPO} ..."
            aws ecr-public delete-repository --repository-name "${OBS_REPO}" --force >/dev/null
          fi
          echo "Creating public repo ${OBS_REPO} ..."
          aws ecr-public create-repository \
            --repository-name "${OBS_REPO}" \
            --catalog-data 'description=Unified observability images (Pre-Prod)' >/dev/null

      - name: Login to ECR Public
        shell: bash
        run: |
          REG="public.ecr.aws/${ECR_PUBLIC_ALIAS}"
          aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin "${REG}"
          echo "REG=${REG}" >> "$GITHUB_ENV"

      - name: Pull upstream images
        run: |
          docker pull prom/prometheus:${PROMETHEUS_VERSION}
          docker pull grafana/grafana:${GRAFANA_VERSION}
          docker pull otel/opentelemetry-collector:${OTELCOL_VERSION}
          docker pull grafana/tempo:${TEMPO_VERSION}

      - name: Tag & Push to ECR Public (Pre-Prod)
        run: |
          docker tag prom/prometheus:${PROMETHEUS_VERSION}            "${REG}/${OBS_REPO}:prometheus-${PROMETHEUS_VERSION}"
          docker tag grafana/grafana:${GRAFANA_VERSION}              "${REG}/${OBS_REPO}:grafana-${GRAFANA_VERSION}"
          docker tag otel/opentelemetry-collector:${OTELCOL_VERSION} "${REG}/${OBS_REPO}:otelcol-${OTELCOL_VERSION}"
          docker tag grafana/tempo:${TEMPO_VERSION}                  "${REG}/${OBS_REPO}:tempo-${TEMPO_VERSION}"
          docker push "${REG}/${OBS_REPO}:prometheus-${PROMETHEUS_VERSION}"
          docker push "${REG}/${OBS_REPO}:grafana-${GRAFANA_VERSION}"
          docker push "${REG}/${OBS_REPO}:otelcol-${OTELCOL_VERSION}"
          docker push "${REG}/${OBS_REPO}:tempo-${TEMPO_VERSION}"

  publish-prod-app:
    name: Publish App (Prod) — purge ON
    runs-on: ubuntu-latest
    needs: [build-test]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    env:
      APP_REPO: mashkenneth/public-student-reg-app/prod-student-reg-app
      SIG_REPO: mashkenneth/public-student-reg-app/prod-student-reg-app-sig
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region:            us-east-1

      - name: Sanity check caller identity
        run: aws sts get-caller-identity

      - name: (Dangerous) Delete & recreate ECR repos (Prod app)
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${ECR_PURGE}" != "true" ]]; then
            echo "ECR_PURGE is not true; skipping destructive purge."
            exit 0
          fi
          for repo in "${APP_REPO}" "${SIG_REPO}"; do
            if aws ecr describe-repositories --repository-names "${repo}" >/dev/null 2>&1; then
              echo "Deleting repository ${repo} (force) ..."
              aws ecr delete-repository --repository-name "${repo}" --force >/dev/null
            fi
            echo "Recreating repository ${repo} (MUTABLE, AES256) ..."
            aws ecr create-repository \
              --repository-name "${repo}" \
              --image-tag-mutability MUTABLE \
              --encryption-configuration encryptionType=AES256 \
              >/dev/null
          done

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: build-and-tests

      - name: Load image
        run: docker load -i app-image.tar.gz

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Push to Prod app repo
        env:
          SHA: ${{ github.sha }}
        run: |
          IMAGE="${ECR_REGISTRY}/${APP_REPO}"
          docker tag "${IMAGE_NAME_LOCAL}" "${IMAGE}:latest"
          docker tag "${IMAGE_NAME_LOCAL}" "${IMAGE}:${SHA::12}"
          docker push "${IMAGE}:latest"
          docker push "${IMAGE}:${SHA::12}"

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.6.0

      - name: Sign Prod app images (cosign keyless)
        env:
          SHA: ${{ github.sha }}
        run: |
          IMAGE="${ECR_REGISTRY}/${APP_REPO}"
          COSIGN_REPOSITORY="${ECR_REGISTRY}/${SIG_REPO}" cosign sign --yes "${IMAGE}:latest"
          COSIGN_REPOSITORY="${ECR_REGISTRY}/${SIG_REPO}" cosign sign --yes "${IMAGE}:${SHA::12}"

  publish-prod-infra:
    name: Publish Observability (Prod Public ECR) — purge ON
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    env:
      OBS_REPO: mashkenneth/public-student-reg-app/prod-observability
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SESSION_TOKEN }}
          aws-region:            us-east-1

      - name: Sanity check caller identity
        run: aws sts get-caller-identity

      - name: (Dangerous) Delete & recreate ECR Public repo (Prod infra)
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${ECR_PURGE}" != "true" ]]; then
            echo "ECR_PURGE is not true; skipping destructive purge."
            exit 0
          fi
          if aws ecr-public describe-repositories --repository-names "${OBS_REPO}" >/dev/null 2>&1; then
            echo "Deleting public repo ${OBS_REPO} ..."
            aws ecr-public delete-repository --repository-name "${OBS_REPO}" --force >/dev/null
          fi
          echo "Creating public repo ${OBS_REPO} ..."
          aws ecr-public create-repository \
            --repository-name "${OBS_REPO}" \
            --catalog-data 'description=Unified observability images (Prod)' >/dev/null

      - name: Login to ECR Public
        shell: bash
        run: |
          REG="public.ecr.aws/${ECR_PUBLIC_ALIAS}"
          aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin "${REG}"
          echo "REG=${REG}" >> "$GITHUB_ENV"

      - name: Pull upstream images
        run: |
          docker pull prom/prometheus:${PROMETHEUS_VERSION}
          docker pull grafana/grafana:${GRAFANA_VERSION}
          docker pull otel/opentelemetry-collector:${OTELCOL_VERSION}
          docker pull grafana/tempo:${TEMPO_VERSION}

      - name: Tag & Push to ECR Public (Prod)
        run: |
          docker tag prom/prometheus:${PROMETHEUS_VERSION}            "${REG}/${OBS_REPO}:prometheus-${PROMETHEUS_VERSION}"
          docker tag grafana/grafana:${GRAFANA_VERSION}              "${REG}/${OBS_REPO}:grafana-${GRAFANA_VERSION}"
          docker tag otel/opentelemetry-collector:${OTELCOL_VERSION} "${REG}/${OBS_REPO}:otelcol-${OTELCOL_VERSION}"
          docker tag grafana/tempo:${TEMPO_VERSION}                  "${REG}/${OBS_REPO}:tempo-${TEMPO_VERSION}"
          docker push "${REG}/${OBS_REPO}:prometheus-${PROMETHEUS_VERSION}"
          docker push "${REG}/${OBS_REPO}:grafana-${GRAFANA_VERSION}"
          docker push "${REG}/${OBS_REPO}:otelcol-${OTELCOL_VERSION}"
          docker push "${REG}/${OBS_REPO}:tempo-${TEMPO_VERSION}"
