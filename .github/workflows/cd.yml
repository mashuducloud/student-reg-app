name: CD - Private ECR push + Public mirror (after CI, hardened, signed, clean)

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write

jobs:
  push-images:
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.head_branch == 'master')
    runs-on: ubuntu-latest
    timeout-minutes: 55
    environment: production

    env:
      AWS_REGION: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_REGION }}
      BACKEND_DOCKERFILE: infra/Dockerfile.backend
      FRONTEND_DOCKERFILE: infra/Dockerfile.frontend
      ECR_REPOSITORY: mashkenneth/student-reg-app
      ECR_REGISTRY: 724772092393.dkr.ecr.us-east-1.amazonaws.com
      IMAGE_SIZE_LIMIT: "838860800"
      COSIGN_EXPERIMENTAL: "true"
      COSIGN_YES: "true"

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials (private ECR)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR (private)
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure PRIVATE ECR repo exists
        shell: bash
        run: |
          set -euo pipefail
          aws ecr describe-repositories --region "${AWS_REGION}" --repository-names "${ECR_REPOSITORY}" >/dev/null 2>&1             || aws ecr create-repository --region "${AWS_REGION}" --repository-name "${ECR_REPOSITORY}" >/dev/null

      - name: Ensure lifecycle policy (keep last 10 backend/frontend tags)
        shell: bash
        run: |
          set -euo pipefail
          cat > policy.json <<'JSON'
          {
            "rules": [
              {
                "rulePriority": 10,
                "description": "Expire old backend- tags, keep last 10",
                "selection": { "tagStatus": "tagged", "tagPrefixList": ["backend-"], "countType": "imageCountMoreThan", "countNumber": 10 },
                "action": { "type": "expire" }
              },
              {
                "rulePriority": 20,
                "description": "Expire old frontend- tags, keep last 10",
                "selection": { "tagStatus": "tagged", "tagPrefixList": ["frontend-"], "countType": "imageCountMoreThan", "countNumber": 10 },
                "action": { "type": "expire" }
              }
            ]
          }
          JSON
          aws ecr put-lifecycle-policy --repository-name "${ECR_REPOSITORY}" --lifecycle-policy-text file://policy.json >/dev/null || true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compute tags
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          sha="${GITHUB_SHA:0:7}"
          echo "sha=$sha" >> "$GITHUB_OUTPUT"
          reg="${{ steps.login-ecr.outputs.registry }}"
          if [ -z "$reg" ]; then reg="${ECR_REGISTRY}"; fi
          base="$reg/${ECR_REPOSITORY}"
          echo "registry=$reg" >> "$GITHUB_OUTPUT"
          echo "base=$base" >> "$GITHUB_OUTPUT"

      - name: Build & push BACKEND (backend- tags)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ env.BACKEND_DOCKERFILE }}
          push: true
          platforms: linux/amd64
          tags: |
            ${{ steps.vars.outputs.base }}:backend-latest
            ${{ steps.vars.outputs.base }}:backend-sha-${{ steps.vars.outputs.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build & push FRONTEND (frontend- tags)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ env.FRONTEND_DOCKERFILE }}
          push: true
          platforms: linux/amd64
          tags: |
            ${{ steps.vars.outputs.base }}:frontend-latest
            ${{ steps.vars.outputs.base }}:frontend-sha-${{ steps.vars.outputs.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Enforce image size budget
        shell: bash
        run: |
          set -euo pipefail
          limit="${IMAGE_SIZE_LIMIT}"
          for tag in "backend-sha-${{ steps.vars.outputs.sha }}" "frontend-sha-${{ steps.vars.outputs.sha }}"; do
            ref="${{ steps.vars.outputs.base }}:${tag}"
            echo "Checking size of $ref"
            docker pull "$ref" >/dev/null
            size=$(docker image inspect "$ref" --format '{{.Size}}')
            echo "Size(bytes)=$size"
            if [ "$size" -gt "$limit" ]; then
              echo "::error ::$ref exceeds size budget ($size > $limit)"; exit 1
            fi
          done

      - name: Trivy scan - backend (HIGH,CRITICAL)
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: ${{ steps.vars.outputs.base }}:backend-sha-${{ steps.vars.outputs.sha }}
          format: 'table'
          severity: 'HIGH,CRITICAL'
          exit-code: '1'
          ignore-unfixed: true

      - name: Trivy scan - frontend (HIGH,CRITICAL)
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: ${{ steps.vars.outputs.base }}:frontend-sha-${{ steps.vars.outputs.sha }}
          format: 'table'
          severity: 'HIGH,CRITICAL'
          exit-code: '1'
          ignore-unfixed: true

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Resolve image digests (private ECR)
        id: digests
        shell: bash
        run: |
          set -euo pipefail
          REPO="${ECR_REPOSITORY}"
          BACKEND_TAG="backend-sha-${{ steps.vars.outputs.sha }}"
          FRONTEND_TAG="frontend-sha-${{ steps.vars.outputs.sha }}"
          B_DIGEST=$(aws ecr batch-get-image --repository-name "$REPO" --image-ids imageTag="$BACKEND_TAG" --query 'images[0].imageId.imageDigest' --output text)
          F_DIGEST=$(aws ecr batch-get-image --repository-name "$REPO" --image-ids imageTag="$FRONTEND_TAG" --query 'images[0].imageId.imageDigest' --output text)
          echo "backend_ref=${{ steps.vars.outputs.registry }}/${ECR_REPOSITORY}@${B_DIGEST}" >> "$GITHUB_OUTPUT"
          echo "frontend_ref=${{ steps.vars.outputs.registry }}/${ECR_REPOSITORY}@${F_DIGEST}" >> "$GITHUB_OUTPUT"

      - name: Cosign sign (keyless) - private images
        shell: bash
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          set -euo pipefail
          cosign sign --yes "${{ steps.digests.outputs.backend_ref }}"
          cosign sign --yes "${{ steps.digests.outputs.frontend_ref }}"

      - name: Cosign verify (keyless) - sanity
        shell: bash
        run: |
          set -euo pipefail
          for ref in "${{ steps.digests.outputs.backend_ref }}" "${{ steps.digests.outputs.frontend_ref }}"; do
            cosign verify               --certificate-oidc-issuer https://token.actions.githubusercontent.com               --certificate-identity-regexp "https://github.com/.+"               "$ref" >/dev/null
          done

      - name: Output pushed & signed images
        run: |
          echo "## Pushed & Signed (PRIVATE ECR)" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.vars.outputs.base }}:backend-latest" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.vars.outputs.base }}:backend-sha-${{ steps.vars.outputs.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.digests.outputs.backend_ref }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.vars.outputs.base }}:frontend-latest" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.vars.outputs.base }}:frontend-sha-${{ steps.vars.outputs.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.digests.outputs.frontend_ref }}" >> $GITHUB_STEP_SUMMARY

  mirror-third-party-public:
    needs: push-images
    if: needs.push-images.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    continue-on-error: true
    environment: production

    env:
      AWS_REGION: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_REGION }}
      PROMETHEUS_TAG: v3.5.0
      GRAFANA_TAG: 12.2.0
      TEMPO_TAG: 2.8.0
      OTELCOL_TAG: 0.135.0
      PUBLIC_REPO_NAME: mashkenneth-public-student-reg-app

    steps:
      - name: Configure AWS credentials (public ECR)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR Public
        id: login-ecr-public
        uses: aws-actions/amazon-ecr-login@v2
        with:
          registry-type: public

      - name: Resolve ECR Public alias
        id: ecr-public
        shell: bash
        env:
          PROVIDED_ALIAS: ${{ fromJSON(secrets.AWS_DEPLOY_SECRET).ECR_PUBLIC_ALIAS }}
        run: |
          set -euo pipefail
          alias="${PROVIDED_ALIAS:-}"
          if [ -z "$alias" ]; then
            alias=$(aws ecr-public describe-registries --region "$AWS_REGION"                      --query 'registries[0].aliases[0].name' --output text 2>/dev/null || true)
          fi
          if [ -z "$alias" ] || [ "$alias" = "None" ]; then
            exit 0
          fi
          echo "alias=$alias" >> "$GITHUB_OUTPUT"
          echo "uri=${{ steps.login-ecr-public.outputs.registry }}/$alias" >> "$GITHUB_OUTPUT"

      - name: Ensure ECR Public repository exists (single repo)
        shell: bash
        run: |
          set -euo pipefail
          aws ecr-public describe-repositories --region "$AWS_REGION" --repository-names "${PUBLIC_REPO_NAME}" >/dev/null 2>&1             || aws ecr-public create-repository --region "$AWS_REGION" --repository-name "${PUBLIC_REPO_NAME}" >/dev/null

      - name: Mirror upstream images → ECR Public (prefix tags)
        shell: bash
        run: |
          set -euo pipefail
          BASE="${{ steps.ecr-public.outputs.uri }}/${{ env.PUBLIC_REPO_NAME }}"
          while read -r line; do
            src=$(echo "$line" | awk '{print $1}')
            prefix=$(echo "$line" | awk '{print $2}')
            docker pull --platform linux/amd64 "$src"
            tag="${prefix}-$(echo "$src" | awk -F: '{print $2}')"
            dst="${BASE}:${tag}"
            docker tag "$src" "$dst"
            docker push "$dst"
            printf "%s %s\n" "$dst" "$src" >> mirrored.txt
          done <<'LIST'
          prom/prometheus:${PROMETHEUS_TAG}           prometheus
          grafana/grafana:${GRAFANA_TAG}              grafana
          grafana/tempo:${TEMPO_TAG}                  tempo
          otel/opentelemetry-collector:${OTELCOL_TAG} otelcol
          LIST

      - name: Summary of mirrored images
        if: always()
        run: |
          echo "## Public ECR Mirrors" >> $GITHUB_STEP_SUMMARY
          if [ -f mirrored.txt ]; then
            while read -r dst src; do
              echo "- ${dst} (from ${src})" >> $GITHUB_STEP_SUMMARY
            done < mirrored.txt
          else
            echo "_No images mirrored (alias or repo missing)_" >> $GITHUB_STEP_SUMMARY
          fi
